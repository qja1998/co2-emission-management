{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*!\r\n* chartjs-plugin-annotation v2.2.1\r\n* https://www.chartjs.org/chartjs-plugin-annotation/index\r\n * (c) 2023 chartjs-plugin-annotation Contributors\r\n * Released under the MIT License\r\n */\nimport { Element, defaults, Animations, Chart } from 'chart.js';\nimport { distanceBetweenPoints, isObject, valueOrDefault, defined, callback, isFunction, toRadians, isArray, toFont, addRoundedRectPath, toTRBLCorners, QUARTER_PI, PI, HALF_PI, TWO_THIRDS_PI, TAU, isNumber, RAD_PER_DEG, toPadding, isFinite, toDegrees, clipArea, unclipArea } from 'chart.js/helpers';\n\n/**\r\n * @typedef { import(\"chart.js\").ChartEvent } ChartEvent\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n */\n\nconst interaction = {\n  modes: {\n    /**\r\n     * Point mode returns all elements that hit test based on the event position\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @return {AnnotationElement[]} - elements that are found\r\n     */\n    point(state, event) {\n      return filterElements(state, event, {\n        intersect: true\n      });\n    },\n    /**\r\n     * Nearest mode returns the element closest to the event position\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @param {Object} options - interaction options to use\r\n     * @return {AnnotationElement[]} - elements that are found (only 1 element)\r\n     */\n    nearest(state, event, options) {\n      return getNearestItem(state, event, options);\n    },\n    /**\r\n     * x mode returns the elements that hit-test at the current x coordinate\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @param {Object} options - interaction options to use\r\n     * @return {AnnotationElement[]} - elements that are found\r\n     */\n    x(state, event, options) {\n      return filterElements(state, event, {\n        intersect: options.intersect,\n        axis: 'x'\n      });\n    },\n    /**\r\n     * y mode returns the elements that hit-test at the current y coordinate\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @param {Object} options - interaction options to use\r\n     * @return {AnnotationElement[]} - elements that are found\r\n     */\n    y(state, event, options) {\n      return filterElements(state, event, {\n        intersect: options.intersect,\n        axis: 'y'\n      });\n    }\n  }\n};\n\n/**\r\n * Returns all elements that hit test based on the event position\r\n * @param {Object} state - the state of the plugin\r\n * @param {ChartEvent} event - the event we are find things at\r\n * @param {Object} options - interaction options to use\r\n * @return {AnnotationElement[]} - elements that are found\r\n */\nfunction getElements(state, event, options) {\n  const mode = interaction.modes[options.mode] || interaction.modes.nearest;\n  return mode(state, event, options);\n}\nfunction inRangeByAxis(element, event, axis) {\n  if (axis !== 'x' && axis !== 'y') {\n    return element.inRange(event.x, event.y, 'x', true) || element.inRange(event.x, event.y, 'y', true);\n  }\n  return element.inRange(event.x, event.y, axis, true);\n}\nfunction getPointByAxis(event, center, axis) {\n  if (axis === 'x') {\n    return {\n      x: event.x,\n      y: center.y\n    };\n  } else if (axis === 'y') {\n    return {\n      x: center.x,\n      y: event.y\n    };\n  }\n  return center;\n}\nfunction filterElements(state, event, options) {\n  return state.visibleElements.filter(element => options.intersect ? element.inRange(event.x, event.y) : inRangeByAxis(element, event, options.axis));\n}\nfunction getNearestItem(state, event, options) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  return filterElements(state, event, options).reduce((nearestItems, element) => {\n    const center = element.getCenterPoint();\n    const evenPoint = getPointByAxis(event, center, options.axis);\n    const distance = distanceBetweenPoints(event, evenPoint);\n    if (distance < minDistance) {\n      nearestItems = [element];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      nearestItems.push(element);\n    }\n    return nearestItems;\n  }, []).sort((a, b) => a._index - b._index).slice(0, 1); // return only the top item;\n}\n\nconst isOlderPart = (act, req) => req > act || act.length > req.length && act.slice(0, req.length) === req;\n\n/**\r\n * @typedef { import('chart.js').Point } Point\r\n * @typedef { import('chart.js').InteractionAxis } InteractionAxis\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n */\n\nconst EPSILON = 0.001;\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\n/**\r\n * @param {Object} obj\r\n * @param {number} from\r\n * @param {number} to\r\n * @returns {Object}\r\n */\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n  return obj;\n}\n\n/**\r\n * @param {Point} point\r\n * @param {Point} center\r\n * @param {number} radius\r\n * @param {number} borderWidth\r\n * @returns {boolean}\r\n */\nfunction inPointRange(point, center, radius, borderWidth) {\n  if (!point || !center || radius <= 0) {\n    return false;\n  }\n  const hBorderWidth = borderWidth / 2;\n  return Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius + hBorderWidth, 2);\n}\n\n/**\r\n * @param {Point} point\r\n * @param {{x: number, y: number, x2: number, y2: number}} rect\r\n * @param {InteractionAxis} axis\r\n * @param {number} borderWidth\r\n * @returns {boolean}\r\n */\nfunction inBoxRange(point, {\n  x,\n  y,\n  x2,\n  y2\n}, axis, borderWidth) {\n  const hBorderWidth = borderWidth / 2;\n  const inRangeX = point.x >= x - hBorderWidth - EPSILON && point.x <= x2 + hBorderWidth + EPSILON;\n  const inRangeY = point.y >= y - hBorderWidth - EPSILON && point.y <= y2 + hBorderWidth + EPSILON;\n  if (axis === 'x') {\n    return inRangeX;\n  } else if (axis === 'y') {\n    return inRangeY;\n  }\n  return inRangeX && inRangeY;\n}\n\n/**\r\n * @param {AnnotationElement} element\r\n * @param {boolean} useFinalPosition\r\n * @returns {Point}\r\n */\nfunction getElementCenterPoint(element, useFinalPosition) {\n  const {\n    centerX,\n    centerY\n  } = element.getProps(['centerX', 'centerY'], useFinalPosition);\n  return {\n    x: centerX,\n    y: centerY\n  };\n}\n\n/**\r\n * @param {string} pkg\r\n * @param {string} min\r\n * @param {string} ver\r\n * @param {boolean} [strict=true]\r\n * @returns {boolean}\r\n */\nfunction requireVersion(pkg, min, ver, strict = true) {\n  const parts = ver.split('.');\n  let i = 0;\n  for (const req of min.split('.')) {\n    const act = parts[i++];\n    if (parseInt(req, 10) < parseInt(act, 10)) {\n      break;\n    }\n    if (isOlderPart(act, req)) {\n      if (strict) {\n        throw new Error(`${pkg} v${ver} is not supported. v${min} or newer is required.`);\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nconst isPercentString = s => typeof s === 'string' && s.endsWith('%');\nconst toPercent = s => parseFloat(s) / 100;\nconst toPositivePercent = s => clamp(toPercent(s), 0, 1);\n\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\r\n * @typedef { import('../../types/options').AnnotationPointCoordinates } AnnotationPointCoordinates\r\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\r\n * @typedef { import('../../types/label').LabelPositionObject } LabelPositionObject\r\n */\n\n/**\r\n * @param {number} size\r\n * @param {number|string} position\r\n * @returns {number}\r\n */\nfunction getRelativePosition(size, position) {\n  if (position === 'start') {\n    return 0;\n  }\n  if (position === 'end') {\n    return size;\n  }\n  if (isPercentString(position)) {\n    return toPositivePercent(position) * size;\n  }\n  return size / 2;\n}\n\n/**\r\n * @param {number} size\r\n * @param {number|string} value\r\n * @param {boolean} [positivePercent=true]\r\n * @returns {number}\r\n */\nfunction getSize(size, value, positivePercent = true) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (isPercentString(value)) {\n    return (positivePercent ? toPositivePercent(value) : toPercent(value)) * size;\n  }\n  return size;\n}\n\n/**\r\n * @param {{x: number, width: number}} size\r\n * @param {CoreLabelOptions} options\r\n * @returns {number}\r\n */\nfunction calculateTextAlignment(size, options) {\n  const {\n    x,\n    width\n  } = size;\n  const textAlign = options.textAlign;\n  if (textAlign === 'center') {\n    return x + width / 2;\n  } else if (textAlign === 'end' || textAlign === 'right') {\n    return x + width;\n  }\n  return x;\n}\n\n/**\r\n * @param {{x: number|string, y: number|string}|string|number} value\r\n * @param {string|number} defaultValue\r\n * @returns {{x: number|string, y: number|string}}\r\n */\nfunction toPosition(value, defaultValue = 'center') {\n  if (isObject(value)) {\n    return {\n      x: valueOrDefault(value.x, defaultValue),\n      y: valueOrDefault(value.y, defaultValue)\n    };\n  }\n  value = valueOrDefault(value, defaultValue);\n  return {\n    x: value,\n    y: value\n  };\n}\n\n/**\r\n * @param {AnnotationPointCoordinates} options\r\n * @returns {boolean}\r\n */\nfunction isBoundToPoint(options) {\n  return options && (defined(options.xValue) || defined(options.yValue));\n}\n\n/**\r\n * @param {Chart} chart\r\n * @param {AnnotationBoxModel} properties\r\n * @param {CoreAnnotationOptions} options\r\n * @param {boolean} [centerBased=false]\r\n * @returns {AnnotationBoxModel}\r\n */\nfunction initAnimationProperties(chart, properties, options, centerBased = false) {\n  const initAnim = options.init;\n  if (!initAnim) {\n    return;\n  } else if (initAnim === true) {\n    return applyDefault(properties, centerBased);\n  }\n  return checkCallbackResult(properties, centerBased, callback(initAnim, [{\n    chart,\n    properties,\n    options\n  }]));\n}\n\n/**\r\n * @param {Object} options\r\n * @param {Array} hooks\r\n * @param {Object} hooksContainer\r\n * @returns {boolean}\r\n */\nfunction loadHooks(options, hooks, hooksContainer) {\n  let activated = false;\n  hooks.forEach(hook => {\n    if (isFunction(options[hook])) {\n      activated = true;\n      hooksContainer[hook] = options[hook];\n    } else if (defined(hooksContainer[hook])) {\n      delete hooksContainer[hook];\n    }\n  });\n  return activated;\n}\nfunction applyDefault({\n  centerX,\n  centerY\n}, centerBased) {\n  if (centerBased) {\n    return {\n      centerX,\n      centerY,\n      radius: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  return {\n    x: centerX,\n    y: centerY,\n    x2: centerX,\n    y2: centerY,\n    width: 0,\n    height: 0\n  };\n}\nfunction checkCallbackResult(properties, centerBased, result) {\n  if (result === true) {\n    return applyDefault(properties, centerBased);\n  } else if (isObject(result)) {\n    return result;\n  }\n}\nconst widthCache = new Map();\nconst notRadius = radius => isNaN(radius) || radius <= 0;\nconst fontsKey = fonts => fonts.reduce(function (prev, item) {\n  prev += item.string;\n  return prev;\n}, '');\n\n/**\r\n * @typedef { import('chart.js').Point } Point\r\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\r\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\r\n */\n\n/**\r\n * Determine if content is an image or a canvas.\r\n * @param {*} content\r\n * @returns boolean|undefined\r\n * @todo move this function to chart.js helpers\r\n */\nfunction isImageOrCanvas(content) {\n  if (content && typeof content === 'object') {\n    const type = content.toString();\n    return type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]';\n  }\n}\n\n/**\r\n * Set the translation on the canvas if the rotation must be applied.\r\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\r\n * @param {Point} point - the point of translation\r\n * @param {number} rotation - rotation (in degrees) to apply\r\n */\nfunction translate(ctx, {\n  x,\n  y\n}, rotation) {\n  if (rotation) {\n    ctx.translate(x, y);\n    ctx.rotate(toRadians(rotation));\n    ctx.translate(-x, -y);\n  }\n}\n\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {Object} options\r\n * @returns {boolean|undefined}\r\n */\nfunction setBorderStyle(ctx, options) {\n  if (options && options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle;\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {Object} options\r\n */\nfunction setShadowStyle(ctx, options) {\n  ctx.shadowColor = options.backgroundShadowColor;\n  ctx.shadowBlur = options.shadowBlur;\n  ctx.shadowOffsetX = options.shadowOffsetX;\n  ctx.shadowOffsetY = options.shadowOffsetY;\n}\n\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {CoreLabelOptions} options\r\n * @returns {{width: number, height: number}}\r\n */\nfunction measureLabelSize(ctx, options) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    return {\n      width: getSize(content.width, options.width),\n      height: getSize(content.height, options.height)\n    };\n  }\n  const optFont = options.font;\n  const fonts = isArray(optFont) ? optFont.map(f => toFont(f)) : [toFont(optFont)];\n  const strokeWidth = options.textStrokeWidth;\n  const lines = isArray(content) ? content : [content];\n  const mapKey = lines.join() + fontsKey(fonts) + strokeWidth + (ctx._measureText ? '-spriting' : '');\n  if (!widthCache.has(mapKey)) {\n    widthCache.set(mapKey, calculateLabelSize(ctx, lines, fonts, strokeWidth));\n  }\n  return widthCache.get(mapKey);\n}\n\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{x: number, y: number, width: number, height: number}} rect\r\n * @param {Object} options\r\n */\nfunction drawBox(ctx, rect, options) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  ctx.save();\n  setShadowStyle(ctx, options);\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x,\n    y,\n    w: width,\n    h: height,\n    radius: clampAll(toTRBLCorners(options.borderRadius), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{x: number, y: number, width: number, height: number}} rect\r\n * @param {CoreLabelOptions} options\r\n */\nfunction drawLabel(ctx, rect, options) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    ctx.save();\n    ctx.globalAlpha = getOpacity(options.opacity, content.style.opacity);\n    ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\n    ctx.restore();\n    return;\n  }\n  const labels = isArray(content) ? content : [content];\n  const optFont = options.font;\n  const fonts = isArray(optFont) ? optFont.map(f => toFont(f)) : [toFont(optFont)];\n  const optColor = options.color;\n  const colors = isArray(optColor) ? optColor : [optColor];\n  const x = calculateTextAlignment(rect, options);\n  const y = rect.y + options.textStrokeWidth / 2;\n  ctx.save();\n  ctx.textBaseline = 'middle';\n  ctx.textAlign = options.textAlign;\n  if (setTextStrokeStyle(ctx, options)) {\n    applyLabelDecoration(ctx, {\n      x,\n      y\n    }, labels, fonts);\n  }\n  applyLabelContent(ctx, {\n    x,\n    y\n  }, labels, {\n    fonts,\n    colors\n  });\n  ctx.restore();\n}\nfunction setTextStrokeStyle(ctx, options) {\n  if (options.textStrokeWidth > 0) {\n    // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\n    ctx.lineJoin = 'round';\n    ctx.miterLimit = 2;\n    ctx.lineWidth = options.textStrokeWidth;\n    ctx.strokeStyle = options.textStrokeColor;\n    return true;\n  }\n}\n\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{radius: number, options: PointAnnotationOptions}} element\r\n * @param {number} x\r\n * @param {number} y\r\n */\nfunction drawPoint(ctx, element, x, y) {\n  const {\n    radius,\n    options\n  } = element;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n  if (isImageOrCanvas(style)) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(rad);\n    ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n    ctx.restore();\n    return;\n  }\n  if (notRadius(radius)) {\n    return;\n  }\n  drawPointStyle(ctx, {\n    x,\n    y,\n    radius,\n    rotation,\n    style,\n    rad\n  });\n}\nfunction drawPointStyle(ctx, {\n  x,\n  y,\n  radius,\n  rotation,\n  style,\n  rad\n}) {\n  let xOffset, yOffset, size, cornerRadius;\n  ctx.beginPath();\n  switch (style) {\n    // Default includes circle\n    default:\n      ctx.arc(x, y, radius, 0, TAU);\n      ctx.closePath();\n      break;\n    case 'triangle':\n      ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n      // NOTE: the rounded rect implementation changed to use `arc` instead of\n      // `quadraticCurveTo` since it generates better results when rect is\n      // almost a circle. 0.516 (instead of 0.5) produces results with visually\n      // closer proportion to the previous impl and it is inscribed in the\n      // circle with `radius`. For more details, see the following PRs:\n      // https://github.com/chartjs/Chart.js/issues/5597\n      // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        ctx.rect(x - size, y - size, 2 * size, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      break;\n    case 'star':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      rad += QUARTER_PI;\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      break;\n    case 'line':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n      break;\n  }\n  ctx.fill();\n}\nfunction calculateLabelSize(ctx, lines, fonts, strokeWidth) {\n  ctx.save();\n  const count = lines.length;\n  let width = 0;\n  let height = strokeWidth;\n  for (let i = 0; i < count; i++) {\n    const font = fonts[Math.min(i, fonts.length - 1)];\n    ctx.font = font.string;\n    const text = lines[i];\n    width = Math.max(width, ctx.measureText(text).width + strokeWidth);\n    height += font.lineHeight;\n  }\n  ctx.restore();\n  return {\n    width,\n    height\n  };\n}\nfunction applyLabelDecoration(ctx, {\n  x,\n  y\n}, labels, fonts) {\n  ctx.beginPath();\n  let lhs = 0;\n  labels.forEach(function (l, i) {\n    const f = fonts[Math.min(i, fonts.length - 1)];\n    const lh = f.lineHeight;\n    ctx.font = f.string;\n    ctx.strokeText(l, x, y + lh / 2 + lhs);\n    lhs += lh;\n  });\n  ctx.stroke();\n}\nfunction applyLabelContent(ctx, {\n  x,\n  y\n}, labels, {\n  fonts,\n  colors\n}) {\n  let lhs = 0;\n  labels.forEach(function (l, i) {\n    const c = colors[Math.min(i, colors.length - 1)];\n    const f = fonts[Math.min(i, fonts.length - 1)];\n    const lh = f.lineHeight;\n    ctx.beginPath();\n    ctx.font = f.string;\n    ctx.fillStyle = c;\n    ctx.fillText(l, x, y + lh / 2 + lhs);\n    lhs += lh;\n    ctx.fill();\n  });\n}\nfunction getOpacity(value, elementValue) {\n  const opacity = isNumber(value) ? value : elementValue;\n  return isNumber(opacity) ? clamp(opacity, 0, 1) : 1;\n}\nconst limitedLineScale = {\n  xScaleID: {\n    min: 'xMin',\n    max: 'xMax',\n    start: 'left',\n    end: 'right',\n    startProp: 'x',\n    endProp: 'x2'\n  },\n  yScaleID: {\n    min: 'yMin',\n    max: 'yMax',\n    start: 'bottom',\n    end: 'top',\n    startProp: 'y',\n    endProp: 'y2'\n  }\n};\n\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import(\"chart.js\").Scale } Scale\r\n * @typedef { import(\"chart.js\").Point } Point\r\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\r\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\r\n * @typedef { import('../../types/options').LineAnnotationOptions } LineAnnotationOptions\r\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\r\n * @typedef { import('../../types/options').PolygonAnnotationOptions } PolygonAnnotationOptions\r\n */\n\n/**\r\n * @param {Scale} scale\r\n * @param {number|string} value\r\n * @param {number} fallback\r\n * @returns {number}\r\n */\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\r\n * Search the scale defined in chartjs by the axis related to the annotation options key.\r\n * @param {{ [key: string]: Scale }} scales\r\n * @param {CoreAnnotationOptions} options\r\n * @param {string} key\r\n * @returns {string}\r\n */\nfunction retrieveScaleID(scales, options, key) {\n  const scaleID = options[key];\n  if (scaleID || key === 'scaleID') {\n    return scaleID;\n  }\n  const axis = key.charAt(0);\n  const axes = Object.values(scales).filter(scale => scale.axis && scale.axis === axis);\n  if (axes.length) {\n    return axes[0].id;\n  }\n  return axis;\n}\n\n/**\r\n * @param {Scale} scale\r\n * @param {{min: number, max: number, start: number, end: number}} options\r\n * @returns {{start: number, end: number}|undefined}\r\n */\nfunction getDimensionByScale(scale, options) {\n  if (scale) {\n    const reverse = scale.options.reverse;\n    const start = scaleValue(scale, options.min, reverse ? options.end : options.start);\n    const end = scaleValue(scale, options.max, reverse ? options.start : options.end);\n    return {\n      start,\n      end\n    };\n  }\n}\n\n/**\r\n * @param {Chart} chart\r\n * @param {CoreAnnotationOptions} options\r\n * @returns {Point}\r\n */\nfunction getChartPoint(chart, options) {\n  const {\n    chartArea,\n    scales\n  } = chart;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n  let x = chartArea.width / 2;\n  let y = chartArea.height / 2;\n  if (xScale) {\n    x = scaleValue(xScale, options.xValue, xScale.left + xScale.width / 2);\n  }\n  if (yScale) {\n    y = scaleValue(yScale, options.yValue, yScale.top + yScale.height / 2);\n  }\n  return {\n    x,\n    y\n  };\n}\n\n/**\r\n * @param {Chart} chart\r\n * @param {CoreAnnotationOptions} options\r\n * @returns {AnnotationBoxModel}\r\n */\nfunction resolveBoxProperties(chart, options) {\n  const scales = chart.scales;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n  if (!xScale && !yScale) {\n    return {};\n  }\n  let {\n    left: x,\n    right: x2\n  } = xScale || chart.chartArea;\n  let {\n    top: y,\n    bottom: y2\n  } = yScale || chart.chartArea;\n  const xDim = getChartDimensionByScale(xScale, {\n    min: options.xMin,\n    max: options.xMax,\n    start: x,\n    end: x2\n  });\n  x = xDim.start;\n  x2 = xDim.end;\n  const yDim = getChartDimensionByScale(yScale, {\n    min: options.yMin,\n    max: options.yMax,\n    start: y2,\n    end: y\n  });\n  y = yDim.start;\n  y2 = yDim.end;\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: x2 - x,\n    height: y2 - y,\n    centerX: x + (x2 - x) / 2,\n    centerY: y + (y2 - y) / 2\n  };\n}\n\n/**\r\n * @param {Chart} chart\r\n * @param {PointAnnotationOptions|PolygonAnnotationOptions} options\r\n * @returns {AnnotationBoxModel}\r\n */\nfunction resolvePointProperties(chart, options) {\n  if (!isBoundToPoint(options)) {\n    const box = resolveBoxProperties(chart, options);\n    let radius = options.radius;\n    if (!radius || isNaN(radius)) {\n      radius = Math.min(box.width, box.height) / 2;\n      options.radius = radius;\n    }\n    const size = radius * 2;\n    const adjustCenterX = box.centerX + options.xAdjust;\n    const adjustCenterY = box.centerY + options.yAdjust;\n    return {\n      x: adjustCenterX - radius,\n      y: adjustCenterY - radius,\n      x2: adjustCenterX + radius,\n      y2: adjustCenterY + radius,\n      centerX: adjustCenterX,\n      centerY: adjustCenterY,\n      width: size,\n      height: size,\n      radius\n    };\n  }\n  return getChartCircle(chart, options);\n}\n/**\r\n * @param {Chart} chart\r\n * @param {LineAnnotationOptions} options\r\n * @returns {AnnotationBoxModel}\r\n */\nfunction resolveLineProperties(chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const scale = scales[options.scaleID];\n  const area = {\n    x: chartArea.left,\n    y: chartArea.top,\n    x2: chartArea.right,\n    y2: chartArea.bottom\n  };\n  if (scale) {\n    resolveFullLineProperties(scale, area, options);\n  } else {\n    resolveLimitedLineProperties(scales, area, options);\n  }\n  return area;\n}\n\n/**\r\n * @param {Chart} chart\r\n * @param {CoreAnnotationOptions} options\r\n * @param {boolean} [centerBased=false]\r\n * @returns {AnnotationBoxModel}\r\n */\nfunction resolveBoxAndLabelProperties(chart, options, centerBased) {\n  const properties = resolveBoxProperties(chart, options);\n  properties.initProperties = initAnimationProperties(chart, properties, options, centerBased);\n  properties.elements = [{\n    type: 'label',\n    optionScope: 'label',\n    properties: resolveLabelElementProperties$1(chart, properties, options),\n    initProperties: properties.initProperties\n  }];\n  return properties;\n}\nfunction getChartCircle(chart, options) {\n  const point = getChartPoint(chart, options);\n  const size = options.radius * 2;\n  return {\n    x: point.x - options.radius + options.xAdjust,\n    y: point.y - options.radius + options.yAdjust,\n    x2: point.x + options.radius + options.xAdjust,\n    y2: point.y + options.radius + options.yAdjust,\n    centerX: point.x + options.xAdjust,\n    centerY: point.y + options.yAdjust,\n    radius: options.radius,\n    width: size,\n    height: size\n  };\n}\nfunction getChartDimensionByScale(scale, options) {\n  const result = getDimensionByScale(scale, options) || options;\n  return {\n    start: Math.min(result.start, result.end),\n    end: Math.max(result.start, result.end)\n  };\n}\nfunction resolveFullLineProperties(scale, area, options) {\n  const min = scaleValue(scale, options.value, NaN);\n  const max = scaleValue(scale, options.endValue, min);\n  if (scale.isHorizontal()) {\n    area.x = min;\n    area.x2 = max;\n  } else {\n    area.y = min;\n    area.y2 = max;\n  }\n}\nfunction resolveLimitedLineProperties(scales, area, options) {\n  for (const scaleId of Object.keys(limitedLineScale)) {\n    const scale = scales[retrieveScaleID(scales, options, scaleId)];\n    if (scale) {\n      const {\n        min,\n        max,\n        start,\n        end,\n        startProp,\n        endProp\n      } = limitedLineScale[scaleId];\n      const dim = getDimensionByScale(scale, {\n        min: options[min],\n        max: options[max],\n        start: scale[start],\n        end: scale[end]\n      });\n      area[startProp] = dim.start;\n      area[endProp] = dim.end;\n    }\n  }\n}\nfunction calculateX({\n  properties,\n  options\n}, labelSize, position, padding) {\n  const {\n    x: start,\n    x2: end,\n    width: size\n  } = properties;\n  return calculatePosition$1({\n    start,\n    end,\n    size,\n    borderWidth: options.borderWidth\n  }, {\n    position: position.x,\n    padding: {\n      start: padding.left,\n      end: padding.right\n    },\n    adjust: options.label.xAdjust,\n    size: labelSize.width\n  });\n}\nfunction calculateY({\n  properties,\n  options\n}, labelSize, position, padding) {\n  const {\n    y: start,\n    y2: end,\n    height: size\n  } = properties;\n  return calculatePosition$1({\n    start,\n    end,\n    size,\n    borderWidth: options.borderWidth\n  }, {\n    position: position.y,\n    padding: {\n      start: padding.top,\n      end: padding.bottom\n    },\n    adjust: options.label.yAdjust,\n    size: labelSize.height\n  });\n}\nfunction calculatePosition$1(boxOpts, labelOpts) {\n  const {\n    start,\n    end,\n    borderWidth\n  } = boxOpts;\n  const {\n    position,\n    padding: {\n      start: padStart,\n      end: padEnd\n    },\n    adjust\n  } = labelOpts;\n  const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\n  return start + borderWidth / 2 + adjust + getRelativePosition(availableSize, position);\n}\nfunction resolveLabelElementProperties$1(chart, properties, options) {\n  const label = options.label;\n  label.backgroundColor = 'transparent';\n  label.callout.display = false;\n  const position = toPosition(label.position);\n  const padding = toPadding(label.padding);\n  const labelSize = measureLabelSize(chart.ctx, label);\n  const x = calculateX({\n    properties,\n    options\n  }, labelSize, position, padding);\n  const y = calculateY({\n    properties,\n    options\n  }, labelSize, position, padding);\n  const width = labelSize.width + padding.width;\n  const height = labelSize.height + padding.height;\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2,\n    rotation: label.rotation\n  };\n}\n\n/**\r\n * @typedef {import('chart.js').Point} Point\r\n */\n\n/**\r\n * Rotate a `point` relative to `center` point by `angle`\r\n * @param {Point} point - the point to rotate\r\n * @param {Point} center - center point for rotation\r\n * @param {number} angle - angle for rotation, in radians\r\n * @returns {Point} rotated point\r\n */\nfunction rotated(point, center, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const cx = center.x;\n  const cy = center.y;\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\nconst moveHooks = ['enter', 'leave'];\n\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\r\n */\n\nconst eventHooks = moveHooks.concat('click');\n\n/**\r\n * @param {Chart} chart\r\n * @param {Object} state\r\n * @param {AnnotationPluginOptions} options\r\n */\nfunction updateListeners(chart, state, options) {\n  state.listened = loadHooks(options, eventHooks, state.listeners);\n  state.moveListened = false;\n  state._getElements = getElements; // for testing\n\n  moveHooks.forEach(hook => {\n    if (isFunction(options[hook])) {\n      state.moveListened = true;\n    }\n  });\n  if (!state.listened || !state.moveListened) {\n    state.annotations.forEach(scope => {\n      if (!state.listened && isFunction(scope.click)) {\n        state.listened = true;\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (isFunction(scope[hook])) {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\r\n * @param {Object} state\r\n * @param {ChartEvent} event\r\n * @param {AnnotationPluginOptions} options\r\n * @return {boolean|undefined}\r\n */\nfunction handleEvent(state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n      case 'mousemove':\n      case 'mouseout':\n        return handleMoveEvents(state, event, options);\n      case 'click':\n        return handleClickEvents(state, event, options);\n    }\n  }\n}\nfunction handleMoveEvents(state, event, options) {\n  if (!state.moveListened) {\n    return;\n  }\n  let elements;\n  if (event.type === 'mousemove') {\n    elements = getElements(state, event, options.interaction);\n  } else {\n    elements = [];\n  }\n  const previous = state.hovered;\n  state.hovered = elements;\n  const context = {\n    state,\n    event\n  };\n  let changed = dispatchMoveEvents(context, 'leave', previous, elements);\n  return dispatchMoveEvents(context, 'enter', elements, previous) || changed;\n}\nfunction dispatchMoveEvents({\n  state,\n  event\n}, hook, elements, checkElements) {\n  let changed;\n  for (const element of elements) {\n    if (checkElements.indexOf(element) < 0) {\n      changed = dispatchEvent(element.options[hook] || state.listeners[hook], element, event) || changed;\n    }\n  }\n  return changed;\n}\nfunction handleClickEvents(state, event, options) {\n  const listeners = state.listeners;\n  const elements = getElements(state, event, options.interaction);\n  let changed;\n  for (const element of elements) {\n    changed = dispatchEvent(element.options.click || listeners.click, element, event) || changed;\n  }\n  return changed;\n}\nfunction dispatchEvent(handler, element, event) {\n  return callback(handler, [element.$context, event]) === true;\n}\n\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n */\n\nconst elementHooks = ['afterDraw', 'beforeDraw'];\n\n/**\r\n * @param {Chart} chart\r\n * @param {Object} state\r\n * @param {AnnotationPluginOptions} options\r\n */\nfunction updateHooks(chart, state, options) {\n  const visibleElements = state.visibleElements;\n  state.hooked = loadHooks(options, elementHooks, state.hooks);\n  if (!state.hooked) {\n    visibleElements.forEach(scope => {\n      if (!state.hooked) {\n        elementHooks.forEach(hook => {\n          if (isFunction(scope.options[hook])) {\n            state.hooked = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\r\n * @param {Object} state\r\n * @param {AnnotationElement} element\r\n * @param {string} hook\r\n */\nfunction invokeHook(state, element, hook) {\n  if (state.hooked) {\n    const callbackHook = element.options[hook] || state.hooks[hook];\n    return callback(callbackHook, [element.$context]);\n  }\n}\n\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import(\"chart.js\").Scale } Scale\r\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\r\n */\n\n/**\r\n * @param {Chart} chart\r\n * @param {Scale} scale\r\n * @param {CoreAnnotationOptions[]} annotations\r\n */\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(chart.scales, scale, annotations);\n  let changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');\n  changed = changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;\n  if (changed && isFunction(scale.handleTickRangeOptions)) {\n    scale.handleTickRangeOptions();\n  }\n}\n\n/**\r\n * @param {CoreAnnotationOptions[]} annotations\r\n * @param {{ [key: string]: Scale }} scales\r\n */\nfunction verifyScaleOptions(annotations, scales) {\n  for (const annotation of annotations) {\n    verifyScaleIDs(annotation, scales);\n  }\n}\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\n  if (isFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\n    const changed = scale[limit] !== range[limit];\n    scale[limit] = range[limit];\n    return changed;\n  }\n}\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\n  return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);\n}\nfunction verifyScaleIDs(annotation, scales) {\n  for (const key of ['scaleID', 'xScaleID', 'yScaleID']) {\n    const scaleID = retrieveScaleID(scales, annotation, key);\n    if (scaleID && !scales[scaleID] && verifyProperties(annotation, key)) {\n      console.warn(`No scale found with id '${scaleID}' for annotation '${annotation.id}'`);\n    }\n  }\n}\nfunction verifyProperties(annotation, key) {\n  if (key === 'scaleID') {\n    return true;\n  }\n  const axis = key.charAt(0);\n  for (const prop of ['Min', 'Max', 'Value']) {\n    if (defined(annotation[axis + prop])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getScaleLimits(scales, scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  const limits = {\n    min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),\n    max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)\n  };\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      updateLimits(annotation, scale, ['value', 'endValue'], limits);\n    } else if (retrieveScaleID(scales, annotation, scaleIDOption) === scaleID) {\n      updateLimits(annotation, scale, [axis + 'Min', axis + 'Max', axis + 'Value'], limits);\n    }\n  }\n  return limits;\n}\nfunction updateLimits(annotation, scale, props, limits) {\n  for (const prop of props) {\n    const raw = annotation[prop];\n    if (defined(raw)) {\n      const value = scale.parse(raw);\n      limits.min = Math.min(limits.min, value);\n      limits.max = Math.max(limits.max, value);\n    }\n  }\n}\nclass BoxAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {\n      x,\n      y\n    } = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    return inBoxRange({\n      x,\n      y\n    }, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options.borderWidth);\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.options.rotation);\n    drawBox(ctx, this, this.options);\n    ctx.restore();\n  }\n  get label() {\n    return this.elements && this.elements[0];\n  }\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n}\nBoxAnnotation.id = 'boxAnnotation';\nBoxAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  init: undefined,\n  label: {\n    backgroundColor: 'transparent',\n    borderWidth: 0,\n    callout: {\n      display: false\n    },\n    color: 'black',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: undefined,\n    textAlign: 'start',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nBoxAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\nconst positions = ['left', 'bottom', 'top', 'right'];\nclass LabelAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {\n      x,\n      y\n    } = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.rotation));\n    return inBoxRange({\n      x,\n      y\n    }, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options.borderWidth);\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const options = this.options;\n    const visible = !defined(this._visible) || this._visible;\n    if (!options.display || !options.content || !visible) {\n      return;\n    }\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.rotation);\n    drawCallout(ctx, this);\n    drawBox(ctx, this, options);\n    drawLabel(ctx, getLabelSize(this), options);\n    ctx.restore();\n  }\n  resolveElementProperties(chart, options) {\n    let point;\n    if (!isBoundToPoint(options)) {\n      const {\n        centerX,\n        centerY\n      } = resolveBoxProperties(chart, options);\n      point = {\n        x: centerX,\n        y: centerY\n      };\n    } else {\n      point = getChartPoint(chart, options);\n    }\n    const padding = toPadding(options.padding);\n    const labelSize = measureLabelSize(chart.ctx, options);\n    const boxSize = measureRect(point, labelSize, options, padding);\n    return {\n      initProperties: initAnimationProperties(chart, boxSize, options),\n      pointX: point.x,\n      pointY: point.y,\n      ...boxSize,\n      rotation: options.rotation\n    };\n  }\n}\nLabelAnnotation.id = 'labelAnnotation';\nLabelAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  callout: {\n    borderCapStyle: 'butt',\n    borderColor: undefined,\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 1,\n    display: false,\n    margin: 5,\n    position: 'auto',\n    side: 5,\n    start: '50%'\n  },\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  init: undefined,\n  opacity: undefined,\n  padding: 6,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\nLabelAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\nfunction measureRect(point, size, options, padding) {\n  const width = size.width + padding.width + options.borderWidth;\n  const height = size.height + padding.height + options.borderWidth;\n  const position = toPosition(options.position, 'center');\n  const x = calculatePosition(point.x, width, options.xAdjust, position.x);\n  const y = calculatePosition(point.y, height, options.yAdjust, position.y);\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2\n  };\n}\nfunction calculatePosition(start, size, adjust = 0, position) {\n  return start - getRelativePosition(size, position) + adjust;\n}\nfunction drawCallout(ctx, element) {\n  const {\n    pointX,\n    pointY,\n    options\n  } = element;\n  const callout = options.callout;\n  const calloutPosition = callout && callout.display && resolveCalloutPosition(element, callout);\n  if (!calloutPosition || isPointInRange(element, callout, calloutPosition)) {\n    return;\n  }\n  ctx.save();\n  ctx.beginPath();\n  const stroke = setBorderStyle(ctx, callout);\n  if (!stroke) {\n    return ctx.restore();\n  }\n  const {\n    separatorStart,\n    separatorEnd\n  } = getCalloutSeparatorCoord(element, calloutPosition);\n  const {\n    sideStart,\n    sideEnd\n  } = getCalloutSideCoord(element, calloutPosition, separatorStart);\n  if (callout.margin > 0 || options.borderWidth === 0) {\n    ctx.moveTo(separatorStart.x, separatorStart.y);\n    ctx.lineTo(separatorEnd.x, separatorEnd.y);\n  }\n  ctx.moveTo(sideStart.x, sideStart.y);\n  ctx.lineTo(sideEnd.x, sideEnd.y);\n  const rotatedPoint = rotated({\n    x: pointX,\n    y: pointY\n  }, element.getCenterPoint(), toRadians(-element.rotation));\n  ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\n  ctx.stroke();\n  ctx.restore();\n}\nfunction getCalloutSeparatorCoord(element, position) {\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = element;\n  const adjust = getCalloutSeparatorAdjust(element, position);\n  let separatorStart, separatorEnd;\n  if (position === 'left' || position === 'right') {\n    separatorStart = {\n      x: x + adjust,\n      y\n    };\n    separatorEnd = {\n      x: separatorStart.x,\n      y: y2\n    };\n  } else {\n    //  position 'top' or 'bottom'\n    separatorStart = {\n      x,\n      y: y + adjust\n    };\n    separatorEnd = {\n      x: x2,\n      y: separatorStart.y\n    };\n  }\n  return {\n    separatorStart,\n    separatorEnd\n  };\n}\nfunction getCalloutSeparatorAdjust(element, position) {\n  const {\n    width,\n    height,\n    options\n  } = element;\n  const adjust = options.callout.margin + options.borderWidth / 2;\n  if (position === 'right') {\n    return width + adjust;\n  } else if (position === 'bottom') {\n    return height + adjust;\n  }\n  return -adjust;\n}\nfunction getCalloutSideCoord(element, position, separatorStart) {\n  const {\n    y,\n    width,\n    height,\n    options\n  } = element;\n  const start = options.callout.start;\n  const side = getCalloutSideAdjust(position, options.callout);\n  let sideStart, sideEnd;\n  if (position === 'left' || position === 'right') {\n    sideStart = {\n      x: separatorStart.x,\n      y: y + getSize(height, start)\n    };\n    sideEnd = {\n      x: sideStart.x + side,\n      y: sideStart.y\n    };\n  } else {\n    //  position 'top' or 'bottom'\n    sideStart = {\n      x: separatorStart.x + getSize(width, start),\n      y: separatorStart.y\n    };\n    sideEnd = {\n      x: sideStart.x,\n      y: sideStart.y + side\n    };\n  }\n  return {\n    sideStart,\n    sideEnd\n  };\n}\nfunction getCalloutSideAdjust(position, options) {\n  const side = options.side;\n  if (position === 'left' || position === 'top') {\n    return -side;\n  }\n  return side;\n}\nfunction resolveCalloutPosition(element, options) {\n  const position = options.position;\n  if (positions.includes(position)) {\n    return position;\n  }\n  return resolveCalloutAutoPosition(element, options);\n}\nfunction resolveCalloutAutoPosition(element, options) {\n  const {\n    x,\n    y,\n    x2,\n    y2,\n    width,\n    height,\n    pointX,\n    pointY,\n    centerX,\n    centerY,\n    rotation\n  } = element;\n  const center = {\n    x: centerX,\n    y: centerY\n  };\n  const start = options.start;\n  const xAdjust = getSize(width, start);\n  const yAdjust = getSize(height, start);\n  const xPoints = [x, x + xAdjust, x + xAdjust, x2];\n  const yPoints = [y + yAdjust, y2, y, y2];\n  const result = [];\n  for (let index = 0; index < 4; index++) {\n    const rotatedPoint = rotated({\n      x: xPoints[index],\n      y: yPoints[index]\n    }, center, toRadians(rotation));\n    result.push({\n      position: positions[index],\n      distance: distanceBetweenPoints(rotatedPoint, {\n        x: pointX,\n        y: pointY\n      })\n    });\n  }\n  return result.sort((a, b) => a.distance - b.distance)[0].position;\n}\nfunction getLabelSize({\n  x,\n  y,\n  width,\n  height,\n  options\n}) {\n  const hBorderWidth = options.borderWidth / 2;\n  const padding = toPadding(options.padding);\n  return {\n    x: x + padding.left + hBorderWidth,\n    y: y + padding.top + hBorderWidth,\n    width: width - padding.left - padding.right - options.borderWidth,\n    height: height - padding.top - padding.bottom - options.borderWidth\n  };\n}\nfunction isPointInRange(element, callout, position) {\n  const {\n    pointX,\n    pointY\n  } = element;\n  const margin = callout.margin;\n  let x = pointX;\n  let y = pointY;\n  if (position === 'left') {\n    x += margin;\n  } else if (position === 'right') {\n    x -= margin;\n  } else if (position === 'top') {\n    y += margin;\n  } else if (position === 'bottom') {\n    y -= margin;\n  }\n  return element.inRange(x, y);\n}\nconst pointInLine = (p1, p2, t) => ({\n  x: p1.x + t * (p2.x - p1.x),\n  y: p1.y + t * (p2.y - p1.y)\n});\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst sqr = v => v * v;\nconst rangeLimit = (mouseX, mouseY, {\n  x,\n  y,\n  x2,\n  y2\n}, axis) => axis === 'y' ? {\n  start: Math.min(y, y2),\n  end: Math.max(y, y2),\n  value: mouseY\n} : {\n  start: Math.min(x, x2),\n  end: Math.max(x, x2),\n  value: mouseX\n};\n// http://www.independent-software.com/determining-coordinates-on-a-html-canvas-bezier-curve.html\nconst coordInCurve = (start, cp, end, t) => (1 - t) * (1 - t) * start + 2 * (1 - t) * t * cp + t * t * end;\nconst pointInCurve = (start, cp, end, t) => ({\n  x: coordInCurve(start.x, cp.x, end.x, t),\n  y: coordInCurve(start.y, cp.y, end.y, t)\n});\nconst coordAngleInCurve = (start, cp, end, t) => 2 * (1 - t) * (cp - start) + 2 * t * (end - cp);\nconst angleInCurve = (start, cp, end, t) => -Math.atan2(coordAngleInCurve(start.x, cp.x, end.x, t), coordAngleInCurve(start.y, cp.y, end.y, t)) + 0.5 * PI;\nclass LineAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const hBorderWidth = this.options.borderWidth / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      const point = {\n        mouseX,\n        mouseY\n      };\n      const {\n        path,\n        ctx\n      } = this;\n      if (path) {\n        setBorderStyle(ctx, this.options);\n        const {\n          chart\n        } = this.$context;\n        const mx = mouseX * chart.currentDevicePixelRatio;\n        const my = mouseY * chart.currentDevicePixelRatio;\n        const result = ctx.isPointInStroke(path, mx, my) || isOnLabel(this, point, useFinalPosition);\n        ctx.restore();\n        return result;\n      }\n      const epsilon = sqr(hBorderWidth);\n      return intersects(this, point, epsilon, useFinalPosition) || isOnLabel(this, point, useFinalPosition);\n    }\n    return inAxisRange(this, {\n      mouseX,\n      mouseY\n    }, axis, {\n      hBorderWidth,\n      useFinalPosition\n    });\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      x,\n      y,\n      x2,\n      y2,\n      cp,\n      options\n    } = this;\n    ctx.save();\n    if (!setBorderStyle(ctx, options)) {\n      // no border width, then line is not drawn\n      return ctx.restore();\n    }\n    setShadowStyle(ctx, options);\n    const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\n    if (options.curve && cp) {\n      drawCurve(ctx, this, cp, length);\n      return ctx.restore();\n    }\n    const {\n      startOpts,\n      endOpts,\n      startAdjust,\n      endAdjust\n    } = getArrowHeads(this);\n    const angle = Math.atan2(y2 - y, x2 - x);\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(0 + startAdjust, 0);\n    ctx.lineTo(length - endAdjust, 0);\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n    drawArrowHead(ctx, 0, startAdjust, startOpts);\n    drawArrowHead(ctx, length, -endAdjust, endOpts);\n    ctx.restore();\n  }\n  get label() {\n    return this.elements && this.elements[0];\n  }\n  resolveElementProperties(chart, options) {\n    const area = resolveLineProperties(chart, options);\n    const {\n      x,\n      y,\n      x2,\n      y2\n    } = area;\n    const inside = isLineInArea(area, chart.chartArea);\n    const properties = inside ? limitLineToArea({\n      x,\n      y\n    }, {\n      x: x2,\n      y: y2\n    }, chart.chartArea) : {\n      x,\n      y,\n      x2,\n      y2,\n      width: Math.abs(x2 - x),\n      height: Math.abs(y2 - y)\n    };\n    properties.centerX = (x2 + x) / 2;\n    properties.centerY = (y2 + y) / 2;\n    properties.initProperties = initAnimationProperties(chart, properties, options);\n    if (options.curve) {\n      const p1 = {\n        x: properties.x,\n        y: properties.y\n      };\n      const p2 = {\n        x: properties.x2,\n        y: properties.y2\n      };\n      properties.cp = getControlPoint(properties, options, distanceBetweenPoints(p1, p2));\n    }\n    const labelProperties = resolveLabelElementProperties(chart, properties, options.label);\n    // additonal prop to manage zoom/pan\n    labelProperties._visible = inside;\n    properties.elements = [{\n      type: 'label',\n      optionScope: 'label',\n      properties: labelProperties,\n      initProperties: properties.initProperties\n    }];\n    return properties;\n  }\n}\nLineAnnotation.id = 'lineAnnotation';\nconst arrowHeadsDefaults = {\n  backgroundColor: undefined,\n  backgroundShadowColor: undefined,\n  borderColor: undefined,\n  borderDash: undefined,\n  borderDashOffset: undefined,\n  borderShadowColor: undefined,\n  borderWidth: undefined,\n  display: undefined,\n  fill: undefined,\n  length: undefined,\n  shadowBlur: undefined,\n  shadowOffsetX: undefined,\n  shadowOffsetY: undefined,\n  width: undefined\n};\nLineAnnotation.defaults = {\n  adjustScaleRange: true,\n  arrowHeads: {\n    display: false,\n    end: Object.assign({}, arrowHeadsDefaults),\n    fill: false,\n    length: 12,\n    start: Object.assign({}, arrowHeadsDefaults),\n    width: 6\n  },\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 2,\n  curve: false,\n  controlPoint: {\n    y: '-50%'\n  },\n  display: true,\n  endValue: undefined,\n  init: undefined,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    backgroundShadowColor: 'transparent',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderShadowColor: 'transparent',\n    borderWidth: 0,\n    callout: Object.assign({}, LabelAnnotation.defaults.callout),\n    color: '#fff',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    textAlign: 'center',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  scaleID: undefined,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  value: undefined,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\nLineAnnotation.descriptors = {\n  arrowHeads: {\n    start: {\n      _fallback: true\n    },\n    end: {\n      _fallback: true\n    },\n    _fallback: true\n  }\n};\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\nfunction inAxisRange(element, {\n  mouseX,\n  mouseY\n}, axis, {\n  hBorderWidth,\n  useFinalPosition\n}) {\n  const limit = rangeLimit(mouseX, mouseY, element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis);\n  return limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth || isOnLabel(element, {\n    mouseX,\n    mouseY\n  }, useFinalPosition, axis);\n}\nfunction isLineInArea({\n  x,\n  y,\n  x2,\n  y2\n}, {\n  top,\n  right,\n  bottom,\n  left\n}) {\n  return !(x < left && x2 < left || x > right && x2 > right || y < top && y2 < top || y > bottom && y2 > bottom);\n}\nfunction limitPointToArea({\n  x,\n  y\n}, p2, {\n  top,\n  right,\n  bottom,\n  left\n}) {\n  if (x < left) {\n    y = interpolateY(left, {\n      x,\n      y\n    }, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = interpolateY(right, {\n      x,\n      y\n    }, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = interpolateX(top, {\n      x,\n      y\n    }, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = interpolateX(bottom, {\n      x,\n      y\n    }, p2);\n    y = bottom;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction limitLineToArea(p1, p2, area) {\n  const {\n    x,\n    y\n  } = limitPointToArea(p1, p2, area);\n  const {\n    x: x2,\n    y: y2\n  } = limitPointToArea(p2, p1, area);\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: Math.abs(x2 - x),\n    height: Math.abs(y2 - y)\n  };\n}\nfunction intersects(element, {\n  mouseX,\n  mouseY\n}, epsilon = EPSILON, useFinalPosition) {\n  // Adapted from https://stackoverflow.com/a/6853926/25507\n  const {\n    x: x1,\n    y: y1,\n    x2,\n    y2\n  } = element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lenSq = sqr(dx) + sqr(dy);\n  const t = lenSq === 0 ? -1 : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;\n  let xx, yy;\n  if (t < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (t > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + t * dx;\n    yy = y1 + t * dy;\n  }\n  return sqr(mouseX - xx) + sqr(mouseY - yy) <= epsilon;\n}\nfunction isOnLabel(element, {\n  mouseX,\n  mouseY\n}, useFinalPosition, axis) {\n  const label = element.label;\n  return label.options.display && label.inRange(mouseX, mouseY, axis, useFinalPosition);\n}\nfunction resolveLabelElementProperties(chart, properties, options) {\n  const borderWidth = options.borderWidth;\n  const padding = toPadding(options.padding);\n  const textSize = measureLabelSize(chart.ctx, options);\n  const width = textSize.width + padding.width + borderWidth;\n  const height = textSize.height + padding.height + borderWidth;\n  return calculateLabelPosition(properties, options, {\n    width,\n    height,\n    padding\n  }, chart.chartArea);\n}\nfunction calculateAutoRotation(properties) {\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = properties;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\nfunction calculateLabelPosition(properties, label, sizes, chartArea) {\n  const {\n    width,\n    height,\n    padding\n  } = sizes;\n  const {\n    xAdjust,\n    yAdjust\n  } = label;\n  const p1 = {\n    x: properties.x,\n    y: properties.y\n  };\n  const p2 = {\n    x: properties.x2,\n    y: properties.y2\n  };\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(properties) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(properties, label, {\n    labelSize: size,\n    padding\n  }, chartArea);\n  const pt = properties.cp ? pointInCurve(p1, properties.cp, p2, t) : pointInLine(p1, p2, t);\n  const xCoordinateSizes = {\n    size: size.w,\n    min: chartArea.left,\n    max: chartArea.right,\n    padding: padding.left\n  };\n  const yCoordinateSizes = {\n    size: size.h,\n    min: chartArea.top,\n    max: chartArea.bottom,\n    padding: padding.top\n  };\n  const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;\n  const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;\n  return {\n    x: centerX - width / 2,\n    y: centerY - height / 2,\n    x2: centerX + width / 2,\n    y2: centerY + height / 2,\n    centerX,\n    centerY,\n    pointX: pt.x,\n    pointY: pt.y,\n    width,\n    height,\n    rotation: toDegrees(rotation)\n  };\n}\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\nfunction calculateT(properties, label, sizes, chartArea) {\n  let t;\n  const space = spaceAround(properties, chartArea);\n  if (label.position === 'start') {\n    t = calculateTAdjust({\n      w: properties.x2 - properties.x,\n      h: properties.y2 - properties.y\n    }, sizes, label, space);\n  } else if (label.position === 'end') {\n    t = 1 - calculateTAdjust({\n      w: properties.x - properties.x2,\n      h: properties.y - properties.y2\n    }, sizes, label, space);\n  } else {\n    t = getRelativePosition(1, label.position);\n  }\n  return t;\n}\nfunction calculateTAdjust(lineSize, sizes, label, space) {\n  const {\n    labelSize,\n    padding\n  } = sizes;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = lineW > 0 && (labelSize.w / 2 + padding.left - space.x) / lineW;\n  const y = lineH > 0 && (labelSize.h / 2 + padding.top - space.y) / lineH;\n  return clamp(Math.max(x, y), 0, 0.25);\n}\nfunction spaceAround(properties, chartArea) {\n  const {\n    x,\n    x2,\n    y,\n    y2\n  } = properties;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l <= r ? 1 : -1,\n    dy: t <= b ? 1 : -1\n  };\n}\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {\n    size,\n    min,\n    max,\n    padding\n  } = labelSizes;\n  const halfSize = size / 2;\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n  if (min >= coordinate - padding - halfSize) {\n    coordinate = min + padding + halfSize;\n  }\n  if (max <= coordinate + padding + halfSize) {\n    coordinate = max - padding - halfSize;\n  }\n  return coordinate;\n}\nfunction getArrowHeads(line) {\n  const options = line.options;\n  const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\n  const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\n  return {\n    startOpts: arrowStartOpts,\n    endOpts: arrowEndOpts,\n    startAdjust: getLineAdjust(line, arrowStartOpts),\n    endAdjust: getLineAdjust(line, arrowEndOpts)\n  };\n}\nfunction getLineAdjust(line, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return 0;\n  }\n  const {\n    length,\n    width\n  } = arrowOpts;\n  const adjust = line.options.borderWidth / 2;\n  const p1 = {\n    x: length,\n    y: width + adjust\n  };\n  const p2 = {\n    x: 0,\n    y: adjust\n  };\n  return Math.abs(interpolateX(0, p1, p2));\n}\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  const {\n    length,\n    width,\n    fill,\n    backgroundColor,\n    borderColor\n  } = arrowOpts;\n  const arrowOffsetX = Math.abs(offset - length) + adjust;\n  ctx.beginPath();\n  setShadowStyle(ctx, arrowOpts);\n  setBorderStyle(ctx, arrowOpts);\n  ctx.moveTo(arrowOffsetX, -width);\n  ctx.lineTo(offset + adjust, 0);\n  ctx.lineTo(arrowOffsetX, width);\n  if (fill === true) {\n    ctx.fillStyle = backgroundColor || borderColor;\n    ctx.closePath();\n    ctx.fill();\n    ctx.shadowColor = 'transparent';\n  } else {\n    ctx.shadowColor = arrowOpts.borderShadowColor;\n  }\n  ctx.stroke();\n}\nfunction getControlPoint(properties, options, distance) {\n  const {\n    x,\n    y,\n    x2,\n    y2,\n    centerX,\n    centerY\n  } = properties;\n  const angle = Math.atan2(y2 - y, x2 - x);\n  const cp = toPosition(options.controlPoint, 0);\n  const point = {\n    x: centerX + getSize(distance, cp.x, false),\n    y: centerY + getSize(distance, cp.y, false)\n  };\n  return rotated(point, {\n    x: centerX,\n    y: centerY\n  }, angle);\n}\nfunction drawArrowHeadOnCurve(ctx, {\n  x,\n  y\n}, {\n  angle,\n  adjust\n}, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  ctx.save();\n  ctx.translate(x, y);\n  ctx.rotate(angle);\n  drawArrowHead(ctx, 0, -adjust, arrowOpts);\n  ctx.restore();\n}\nfunction drawCurve(ctx, element, cp, length) {\n  const {\n    x,\n    y,\n    x2,\n    y2,\n    options\n  } = element;\n  const {\n    startOpts,\n    endOpts,\n    startAdjust,\n    endAdjust\n  } = getArrowHeads(element);\n  const p1 = {\n    x,\n    y\n  };\n  const p2 = {\n    x: x2,\n    y: y2\n  };\n  const startAngle = angleInCurve(p1, cp, p2, 0);\n  const endAngle = angleInCurve(p1, cp, p2, 1) - PI;\n  const ps = pointInCurve(p1, cp, p2, startAdjust / length);\n  const pe = pointInCurve(p1, cp, p2, 1 - endAdjust / length);\n  const path = new Path2D();\n  ctx.beginPath();\n  path.moveTo(ps.x, ps.y);\n  path.quadraticCurveTo(cp.x, cp.y, pe.x, pe.y);\n  ctx.shadowColor = options.borderShadowColor;\n  ctx.stroke(path);\n  element.path = path;\n  element.ctx = ctx;\n  drawArrowHeadOnCurve(ctx, ps, {\n    angle: startAngle,\n    adjust: startAdjust\n  }, startOpts);\n  drawArrowHeadOnCurve(ctx, pe, {\n    angle: endAngle,\n    adjust: endAdjust\n  }, endOpts);\n}\nclass EllipseAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const rotation = this.options.rotation;\n    const borderWidth = this.options.borderWidth;\n    if (axis !== 'x' && axis !== 'y') {\n      return pointInEllipse({\n        x: mouseX,\n        y: mouseY\n      }, this.getProps(['width', 'height', 'centerX', 'centerY'], useFinalPosition), rotation, borderWidth);\n    }\n    const {\n      x,\n      y,\n      x2,\n      y2\n    } = this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n    const hBorderWidth = borderWidth / 2;\n    const limit = axis === 'y' ? {\n      start: y,\n      end: y2\n    } : {\n      start: x,\n      end: x2\n    };\n    const rotatedPoint = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-rotation));\n    return rotatedPoint[axis] >= limit.start - hBorderWidth - EPSILON && rotatedPoint[axis] <= limit.end + hBorderWidth + EPSILON;\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      width,\n      height,\n      centerX,\n      centerY,\n      options\n    } = this;\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), options.rotation);\n    setShadowStyle(ctx, this.options);\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    const stroke = setBorderStyle(ctx, options);\n    ctx.ellipse(centerX, centerY, height / 2, width / 2, PI / 2, 0, 2 * PI);\n    ctx.fill();\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n  get label() {\n    return this.elements && this.elements[0];\n  }\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options, true);\n  }\n}\nEllipseAnnotation.id = 'ellipseAnnotation';\nEllipseAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  init: undefined,\n  label: Object.assign({}, BoxAnnotation.defaults.label),\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nEllipseAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\nfunction pointInEllipse(p, ellipse, rotation, borderWidth) {\n  const {\n    width,\n    height,\n    centerX,\n    centerY\n  } = ellipse;\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n  // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\n  const angle = toRadians(rotation || 0);\n  const hBorderWidth = borderWidth / 2 || 0;\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const a = Math.pow(cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY), 2);\n  const b = Math.pow(sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY), 2);\n  return a / Math.pow(xRadius + hBorderWidth, 2) + b / Math.pow(yRadius + hBorderWidth, 2) <= 1.0001;\n}\nclass PointAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {\n      x,\n      y,\n      x2,\n      y2,\n      width\n    } = this.getProps(['x', 'y', 'x2', 'y2', 'width'], useFinalPosition);\n    const borderWidth = this.options.borderWidth;\n    if (axis !== 'x' && axis !== 'y') {\n      return inPointRange({\n        x: mouseX,\n        y: mouseY\n      }, this.getCenterPoint(useFinalPosition), width / 2, borderWidth);\n    }\n    const hBorderWidth = borderWidth / 2;\n    const limit = axis === 'y' ? {\n      start: y,\n      end: y2,\n      value: mouseY\n    } : {\n      start: x,\n      end: x2,\n      value: mouseX\n    };\n    return limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth;\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const options = this.options;\n    const borderWidth = options.borderWidth;\n    if (options.radius < 0.1) {\n      return;\n    }\n    ctx.save();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    drawPoint(ctx, this, this.centerX, this.centerY);\n    if (stroke && !isImageOrCanvas(options.pointStyle)) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n    options.borderWidth = borderWidth;\n  }\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    properties.initProperties = initAnimationProperties(chart, properties, options, true);\n    return properties;\n  }\n}\nPointAnnotation.id = 'pointAnnotation';\nPointAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  init: undefined,\n  pointStyle: 'circle',\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nclass PolygonAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    if (axis !== 'x' && axis !== 'y') {\n      return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\n    }\n    const rotatedPoint = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    const axisPoints = this.elements.map(point => axis === 'y' ? point.bY : point.bX);\n    const start = Math.min(...axisPoints);\n    const end = Math.max(...axisPoints);\n    return rotatedPoint[axis] >= start && rotatedPoint[axis] <= end;\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      elements,\n      options\n    } = this;\n    ctx.save();\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    let first = true;\n    for (const el of elements) {\n      if (first) {\n        ctx.moveTo(el.x, el.y);\n        first = false;\n      } else {\n        ctx.lineTo(el.x, el.y);\n      }\n    }\n    ctx.closePath();\n    ctx.fill();\n    // If no border, don't draw it\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    const {\n      sides,\n      rotation\n    } = options;\n    const elements = [];\n    const angle = 2 * PI / sides;\n    let rad = rotation * RAD_PER_DEG;\n    for (let i = 0; i < sides; i++, rad += angle) {\n      const elProps = buildPointElement(properties, options, rad);\n      elProps.initProperties = initAnimationProperties(chart, properties, options);\n      elements.push(elProps);\n    }\n    properties.elements = elements;\n    return properties;\n  }\n}\nPolygonAnnotation.id = 'polygonAnnotation';\nPolygonAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  init: undefined,\n  point: {\n    radius: 0\n  },\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  sides: 3,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\nPolygonAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nfunction buildPointElement({\n  centerX,\n  centerY\n}, {\n  radius,\n  borderWidth\n}, rad) {\n  const halfBorder = borderWidth / 2;\n  const sin = Math.sin(rad);\n  const cos = Math.cos(rad);\n  const point = {\n    x: centerX + sin * radius,\n    y: centerY - cos * radius\n  };\n  return {\n    type: 'point',\n    optionScope: 'point',\n    properties: {\n      x: point.x,\n      y: point.y,\n      centerX: point.x,\n      centerY: point.y,\n      bX: centerX + sin * (radius + halfBorder),\n      bY: centerY - cos * (radius + halfBorder)\n    }\n  };\n}\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\n  let isInside = false;\n  let A = points[points.length - 1].getProps(['bX', 'bY'], useFinalPosition);\n  for (const point of points) {\n    const B = point.getProps(['bX', 'bY'], useFinalPosition);\n    if (B.bY > y !== A.bY > y && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\n      isInside = !isInside;\n    }\n    A = B;\n  }\n  return isInside;\n}\nconst annotationTypes = {\n  box: BoxAnnotation,\n  ellipse: EllipseAnnotation,\n  label: LabelAnnotation,\n  line: LineAnnotation,\n  point: PointAnnotation,\n  polygon: PolygonAnnotation\n};\n\n/**\r\n * Register fallback for annotation elements\r\n * For example lineAnnotation options would be looked through:\r\n * - the annotation object (options.plugins.annotation.annotations[id])\r\n * - element options (options.elements.lineAnnotation)\r\n * - element defaults (defaults.elements.lineAnnotation)\r\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\r\n */\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation.common'\n  });\n});\nconst directUpdater = {\n  update: Object.assign\n};\nconst hooks$1 = eventHooks.concat(elementHooks);\nconst resolve = (value, optDefs) => isObject(optDefs) ? resolveObj(value, optDefs) : value;\n\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import(\"chart.js\").UpdateMode } UpdateMode\r\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\r\n */\n\n/**\r\n * @param {string} prop\r\n * @returns {boolean}\r\n */\nconst isIndexable = prop => prop === 'color' || prop === 'font';\n\n/**\r\n * Resolve the annotation type, checking if is supported.\r\n * @param {string} [type=line] - annotation type\r\n * @returns {string} resolved annotation type\r\n */\nfunction resolveType(type = 'line') {\n  if (annotationTypes[type]) {\n    return type;\n  }\n  console.warn(`Unknown annotation type: '${type}', defaulting to 'line'`);\n  return 'line';\n}\n\n/**\r\n * @param {Chart} chart\r\n * @param {Object} state\r\n * @param {AnnotationPluginOptions} options\r\n * @param {UpdateMode} mode\r\n */\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n  for (let i = 0; i < annotations.length; i++) {\n    const annotationOptions = annotations[i];\n    const element = getOrCreateElement(elements, i, annotationOptions.type);\n    const resolver = annotationOptions.setContext(getContext(chart, element, annotationOptions));\n    const properties = element.resolveElementProperties(chart, resolver);\n    properties.skip = toSkip(properties);\n    if ('elements' in properties) {\n      updateSubElements(element, properties.elements, resolver, animations);\n      // Remove the sub-element definitions from properties, so the actual elements\n      // are not overwritten by their definitions\n      delete properties.elements;\n    }\n    if (!defined(element.x)) {\n      // If the element is newly created, assing the properties directly - to\n      // make them readily awailable to any scriptable options. If we do not do this,\n      // the properties retruned by `resolveElementProperties` are available only\n      // after options resolution.\n      Object.assign(element, properties);\n    }\n    Object.assign(element, properties.initProperties);\n    properties.options = resolveAnnotationOptions(resolver);\n    animations.update(element, properties);\n  }\n}\nfunction toSkip(properties) {\n  return isNaN(properties.x) || isNaN(properties.y);\n}\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\nfunction updateSubElements(mainElement, elements, resolver, animations) {\n  const subElements = mainElement.elements || (mainElement.elements = []);\n  subElements.length = elements.length;\n  for (let i = 0; i < elements.length; i++) {\n    const definition = elements[i];\n    const properties = definition.properties;\n    const subElement = getOrCreateElement(subElements, i, definition.type, definition.initProperties);\n    const subResolver = resolver[definition.optionScope].override(definition);\n    properties.options = resolveAnnotationOptions(subResolver);\n    animations.update(subElement, properties);\n  }\n}\nfunction getOrCreateElement(elements, index, type, initProperties) {\n  const elementClass = annotationTypes[resolveType(type)];\n  let element = elements[index];\n  if (!element || !(element instanceof elementClass)) {\n    element = elements[index] = new elementClass();\n    Object.assign(element, initProperties);\n  }\n  return element;\n}\nfunction resolveAnnotationOptions(resolver) {\n  const elementClass = annotationTypes[resolveType(resolver.type)];\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elementClass.defaults), resolveObj(resolver, elementClass.defaultRoutes));\n  for (const hook of hooks$1) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const prop of Object.keys(defs)) {\n    const optDefs = defs[prop];\n    const value = resolver[prop];\n    if (isIndexable(prop) && isArray(value)) {\n      result[prop] = value.map(item => resolve(item, optDefs));\n    } else {\n      result[prop] = resolve(value, optDefs);\n    }\n  }\n  return result;\n}\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\nvar version = \"2.2.1\";\nconst chartStates = new Map();\nconst hooks = eventHooks.concat(elementHooks);\nvar annotation = {\n  id: 'annotation',\n  version,\n  beforeRegister() {\n    requireVersion('chart.js', '3.7', Chart.version);\n  },\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      visibleElements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false,\n      hooks: {},\n      hooked: false,\n      hovered: []\n    });\n  },\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n    verifyScaleOptions(annotations, chart.scales);\n  },\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\n  },\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n    state.visibleElements = state.elements.filter(el => !el.skip && el.options.display);\n    updateHooks(chart, state, options);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options.clip);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options.clip);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options.clip);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options.clip);\n  },\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    if (handleEvent(state, args.event, options)) {\n      args.changed = true;\n    }\n  },\n  afterDestroy(chart) {\n    chartStates.delete(chart);\n  },\n  _getState(chart) {\n    return chartStates.get(chart);\n  },\n  defaults: {\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height', 'centerX', 'centerY', 'pointX', 'pointY', 'radius'],\n        type: 'number'\n      }\n    },\n    clip: true,\n    interaction: {\n      mode: undefined,\n      axis: undefined,\n      intersect: undefined\n    },\n    common: {\n      drawTime: 'afterDatasetsDraw',\n      init: false,\n      label: {}\n    }\n  },\n  descriptors: {\n    _indexable: false,\n    _scriptable: prop => !hooks.includes(prop) && prop !== 'init',\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[resolveType(opts.type)].id}`\n    },\n    interaction: {\n      _fallback: true\n    },\n    common: {\n      label: {\n        _indexable: isIndexable,\n        _fallback: true\n      },\n      _indexable: isIndexable\n    }\n  },\n  additionalOptionScopes: ['']\n};\nfunction draw(chart, caller, clip) {\n  const {\n    ctx,\n    chartArea\n  } = chart;\n  const state = chartStates.get(chart);\n  if (clip) {\n    clipArea(ctx, chartArea);\n  }\n  const drawableElements = getDrawableElements(state.visibleElements, caller).sort((a, b) => a.element.options.z - b.element.options.z);\n  for (const item of drawableElements) {\n    drawElement(ctx, chartArea, state, item);\n  }\n  if (clip) {\n    unclipArea(ctx);\n  }\n}\nfunction getDrawableElements(elements, caller) {\n  const drawableElements = [];\n  for (const el of elements) {\n    if (el.options.drawTime === caller) {\n      drawableElements.push({\n        element: el,\n        main: true\n      });\n    }\n    if (el.elements && el.elements.length) {\n      for (const sub of el.elements) {\n        if (sub.options.display && sub.options.drawTime === caller) {\n          drawableElements.push({\n            element: sub\n          });\n        }\n      }\n    }\n  }\n  return drawableElements;\n}\nfunction drawElement(ctx, chartArea, state, item) {\n  const el = item.element;\n  if (item.main) {\n    invokeHook(state, el, 'beforeDraw');\n    el.draw(ctx, chartArea);\n    invokeHook(state, el, 'afterDraw');\n  } else {\n    el.draw(ctx, chartArea);\n  }\n}\nexport { annotation as default };","map":{"version":3,"names":["Element","defaults","Animations","Chart","distanceBetweenPoints","isObject","valueOrDefault","defined","callback","isFunction","toRadians","isArray","toFont","addRoundedRectPath","toTRBLCorners","QUARTER_PI","PI","HALF_PI","TWO_THIRDS_PI","TAU","isNumber","RAD_PER_DEG","toPadding","isFinite","toDegrees","clipArea","unclipArea","interaction","modes","point","state","event","filterElements","intersect","nearest","options","getNearestItem","x","axis","y","getElements","mode","inRangeByAxis","element","inRange","getPointByAxis","center","visibleElements","filter","minDistance","Number","POSITIVE_INFINITY","reduce","nearestItems","getCenterPoint","evenPoint","distance","push","sort","a","b","_index","slice","isOlderPart","act","req","length","EPSILON","clamp","from","to","Math","min","max","clampAll","obj","key","Object","keys","inPointRange","radius","borderWidth","hBorderWidth","pow","inBoxRange","x2","y2","inRangeX","inRangeY","getElementCenterPoint","useFinalPosition","centerX","centerY","getProps","requireVersion","pkg","ver","strict","parts","split","i","parseInt","Error","isPercentString","s","endsWith","toPercent","parseFloat","toPositivePercent","getRelativePosition","size","position","getSize","value","positivePercent","calculateTextAlignment","width","textAlign","toPosition","defaultValue","isBoundToPoint","xValue","yValue","initAnimationProperties","chart","properties","centerBased","initAnim","init","applyDefault","checkCallbackResult","loadHooks","hooks","hooksContainer","activated","forEach","hook","height","result","widthCache","Map","notRadius","isNaN","fontsKey","fonts","prev","item","string","isImageOrCanvas","content","type","toString","translate","ctx","rotation","rotate","setBorderStyle","lineCap","borderCapStyle","setLineDash","borderDash","lineDashOffset","borderDashOffset","lineJoin","borderJoinStyle","lineWidth","strokeStyle","borderColor","setShadowStyle","shadowColor","backgroundShadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","measureLabelSize","optFont","font","map","f","strokeWidth","textStrokeWidth","lines","mapKey","join","_measureText","has","set","calculateLabelSize","get","drawBox","rect","save","stroke","fillStyle","backgroundColor","beginPath","w","h","borderRadius","closePath","fill","borderShadowColor","restore","drawLabel","globalAlpha","getOpacity","opacity","style","drawImage","labels","optColor","color","colors","textBaseline","setTextStrokeStyle","applyLabelDecoration","applyLabelContent","miterLimit","textStrokeColor","drawPoint","pointStyle","rad","drawPointStyle","xOffset","yOffset","cornerRadius","arc","moveTo","sin","cos","lineTo","SQRT1_2","count","text","measureText","lineHeight","lhs","l","lh","strokeText","c","fillText","elementValue","limitedLineScale","xScaleID","start","end","startProp","endProp","yScaleID","scaleValue","scale","fallback","parse","getPixelForValue","retrieveScaleID","scales","scaleID","charAt","axes","values","id","getDimensionByScale","reverse","getChartPoint","chartArea","xScale","yScale","left","top","resolveBoxProperties","right","bottom","xDim","getChartDimensionByScale","xMin","xMax","yDim","yMin","yMax","resolvePointProperties","box","adjustCenterX","xAdjust","adjustCenterY","yAdjust","getChartCircle","resolveLineProperties","area","resolveFullLineProperties","resolveLimitedLineProperties","resolveBoxAndLabelProperties","initProperties","elements","optionScope","resolveLabelElementProperties$1","NaN","endValue","isHorizontal","scaleId","dim","calculateX","labelSize","padding","calculatePosition$1","adjust","label","calculateY","boxOpts","labelOpts","padStart","padEnd","availableSize","callout","display","rotated","angle","cx","cy","moveHooks","eventHooks","concat","updateListeners","listened","listeners","moveListened","_getElements","annotations","scope","click","handleEvent","handleMoveEvents","handleClickEvents","previous","hovered","context","changed","dispatchMoveEvents","checkElements","indexOf","dispatchEvent","handler","$context","elementHooks","updateHooks","hooked","invokeHook","callbackHook","adjustScaleRange","range","getScaleLimits","changeScaleLimit","handleTickRangeOptions","verifyScaleOptions","annotation","verifyScaleIDs","limit","suggestedLimit","scaleLimitDefined","scaleOptions","verifyProperties","console","warn","prop","scaleIDOption","limits","NEGATIVE_INFINITY","updateLimits","props","raw","BoxAnnotation","mouseX","mouseY","draw","resolveElementProperties","undefined","drawTime","family","weight","z","defaultRoutes","descriptors","_fallback","positions","LabelAnnotation","visible","_visible","drawCallout","getLabelSize","boxSize","measureRect","pointX","pointY","margin","side","calculatePosition","calloutPosition","resolveCalloutPosition","isPointInRange","separatorStart","separatorEnd","getCalloutSeparatorCoord","sideStart","sideEnd","getCalloutSideCoord","rotatedPoint","getCalloutSeparatorAdjust","getCalloutSideAdjust","includes","resolveCalloutAutoPosition","xPoints","yPoints","index","pointInLine","p1","p2","t","interpolateX","abs","interpolateY","sqr","v","rangeLimit","coordInCurve","cp","pointInCurve","coordAngleInCurve","angleInCurve","atan2","LineAnnotation","path","mx","currentDevicePixelRatio","my","isPointInStroke","isOnLabel","epsilon","intersects","inAxisRange","sqrt","curve","drawCurve","startOpts","endOpts","startAdjust","endAdjust","getArrowHeads","drawArrowHead","inside","isLineInArea","limitLineToArea","getControlPoint","labelProperties","resolveLabelElementProperties","arrowHeadsDefaults","arrowHeads","assign","controlPoint","limitPointToArea","x1","y1","dx","dy","lenSq","xx","yy","textSize","calculateLabelPosition","calculateAutoRotation","sizes","rotatedSize","calculateT","pt","xCoordinateSizes","yCoordinateSizes","adjustLabelCoordinate","space","spaceAround","calculateTAdjust","lineSize","lineW","lineH","r","coordinate","labelSizes","halfSize","line","arrowStartOpts","arrowEndOpts","getLineAdjust","arrowOpts","offset","arrowOffsetX","drawArrowHeadOnCurve","startAngle","endAngle","ps","pe","Path2D","quadraticCurveTo","EllipseAnnotation","pointInEllipse","ellipse","p","xRadius","yRadius","cosAngle","sinAngle","PointAnnotation","PolygonAnnotation","pointIsInPolygon","axisPoints","bY","bX","first","el","sides","elProps","buildPointElement","halfBorder","points","isInside","A","B","annotationTypes","polygon","describe","directUpdater","update","hooks$1","resolve","optDefs","resolveObj","isIndexable","resolveType","updateElements","animations","resolveAnimations","resyncElements","annotationOptions","getOrCreateElement","resolver","setContext","getContext","skip","toSkip","updateSubElements","resolveAnnotationOptions","animOpts","mainElement","subElements","definition","subElement","subResolver","override","elementClass","defs","create","add","splice","Array","version","chartStates","beforeRegister","afterRegister","register","afterUnregister","unregister","beforeInit","beforeUpdate","args","afterDataLimits","afterUpdate","beforeDatasetsDraw","_args","clip","afterDatasetsDraw","beforeDraw","afterDraw","beforeEvent","afterDestroy","delete","_getState","numbers","common","_indexable","_scriptable","_allKeys","opts","additionalOptionScopes","caller","drawableElements","getDrawableElements","drawElement","main","sub","default"],"sources":["C:/Users/user/Desktop/CarbonVueproject/co2-emission-management/vueProject/node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js"],"sourcesContent":["/*!\r\n* chartjs-plugin-annotation v2.2.1\r\n* https://www.chartjs.org/chartjs-plugin-annotation/index\r\n * (c) 2023 chartjs-plugin-annotation Contributors\r\n * Released under the MIT License\r\n */\r\nimport { Element, defaults, Animations, Chart } from 'chart.js';\r\nimport { distanceBetweenPoints, isObject, valueOrDefault, defined, callback, isFunction, toRadians, isArray, toFont, addRoundedRectPath, toTRBLCorners, QUARTER_PI, PI, HALF_PI, TWO_THIRDS_PI, TAU, isNumber, RAD_PER_DEG, toPadding, isFinite, toDegrees, clipArea, unclipArea } from 'chart.js/helpers';\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").ChartEvent } ChartEvent\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n */\r\n\r\nconst interaction = {\r\n  modes: {\r\n    /**\r\n     * Point mode returns all elements that hit test based on the event position\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @return {AnnotationElement[]} - elements that are found\r\n     */\r\n    point(state, event) {\r\n      return filterElements(state, event, {intersect: true});\r\n    },\r\n\r\n    /**\r\n     * Nearest mode returns the element closest to the event position\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @param {Object} options - interaction options to use\r\n     * @return {AnnotationElement[]} - elements that are found (only 1 element)\r\n     */\r\n    nearest(state, event, options) {\r\n      return getNearestItem(state, event, options);\r\n    },\r\n    /**\r\n     * x mode returns the elements that hit-test at the current x coordinate\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @param {Object} options - interaction options to use\r\n     * @return {AnnotationElement[]} - elements that are found\r\n     */\r\n    x(state, event, options) {\r\n      return filterElements(state, event, {intersect: options.intersect, axis: 'x'});\r\n    },\r\n\r\n    /**\r\n     * y mode returns the elements that hit-test at the current y coordinate\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @param {Object} options - interaction options to use\r\n     * @return {AnnotationElement[]} - elements that are found\r\n     */\r\n    y(state, event, options) {\r\n      return filterElements(state, event, {intersect: options.intersect, axis: 'y'});\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Returns all elements that hit test based on the event position\r\n * @param {Object} state - the state of the plugin\r\n * @param {ChartEvent} event - the event we are find things at\r\n * @param {Object} options - interaction options to use\r\n * @return {AnnotationElement[]} - elements that are found\r\n */\r\nfunction getElements(state, event, options) {\r\n  const mode = interaction.modes[options.mode] || interaction.modes.nearest;\r\n  return mode(state, event, options);\r\n}\r\n\r\nfunction inRangeByAxis(element, event, axis) {\r\n  if (axis !== 'x' && axis !== 'y') {\r\n    return element.inRange(event.x, event.y, 'x', true) || element.inRange(event.x, event.y, 'y', true);\r\n  }\r\n  return element.inRange(event.x, event.y, axis, true);\r\n}\r\n\r\nfunction getPointByAxis(event, center, axis) {\r\n  if (axis === 'x') {\r\n    return {x: event.x, y: center.y};\r\n  } else if (axis === 'y') {\r\n    return {x: center.x, y: event.y};\r\n  }\r\n  return center;\r\n}\r\n\r\nfunction filterElements(state, event, options) {\r\n  return state.visibleElements.filter((element) => options.intersect ? element.inRange(event.x, event.y) : inRangeByAxis(element, event, options.axis));\r\n}\r\n\r\nfunction getNearestItem(state, event, options) {\r\n  let minDistance = Number.POSITIVE_INFINITY;\r\n\r\n  return filterElements(state, event, options)\r\n    .reduce((nearestItems, element) => {\r\n      const center = element.getCenterPoint();\r\n      const evenPoint = getPointByAxis(event, center, options.axis);\r\n      const distance = distanceBetweenPoints(event, evenPoint);\r\n      if (distance < minDistance) {\r\n        nearestItems = [element];\r\n        minDistance = distance;\r\n      } else if (distance === minDistance) {\r\n        // Can have multiple items at the same distance in which case we sort by size\r\n        nearestItems.push(element);\r\n      }\r\n\r\n      return nearestItems;\r\n    }, [])\r\n    .sort((a, b) => a._index - b._index)\r\n    .slice(0, 1); // return only the top item;\r\n}\r\n\r\nconst isOlderPart = (act, req) => req > act || (act.length > req.length && act.slice(0, req.length) === req);\r\n\r\n/**\r\n * @typedef { import('chart.js').Point } Point\r\n * @typedef { import('chart.js').InteractionAxis } InteractionAxis\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n */\r\n\r\nconst EPSILON = 0.001;\r\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\r\n\r\n/**\r\n * @param {Object} obj\r\n * @param {number} from\r\n * @param {number} to\r\n * @returns {Object}\r\n */\r\nfunction clampAll(obj, from, to) {\r\n  for (const key of Object.keys(obj)) {\r\n    obj[key] = clamp(obj[key], from, to);\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * @param {Point} point\r\n * @param {Point} center\r\n * @param {number} radius\r\n * @param {number} borderWidth\r\n * @returns {boolean}\r\n */\r\nfunction inPointRange(point, center, radius, borderWidth) {\r\n  if (!point || !center || radius <= 0) {\r\n    return false;\r\n  }\r\n  const hBorderWidth = borderWidth / 2;\r\n  return (Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2)) <= Math.pow(radius + hBorderWidth, 2);\r\n}\r\n\r\n/**\r\n * @param {Point} point\r\n * @param {{x: number, y: number, x2: number, y2: number}} rect\r\n * @param {InteractionAxis} axis\r\n * @param {number} borderWidth\r\n * @returns {boolean}\r\n */\r\nfunction inBoxRange(point, {x, y, x2, y2}, axis, borderWidth) {\r\n  const hBorderWidth = borderWidth / 2;\r\n  const inRangeX = point.x >= x - hBorderWidth - EPSILON && point.x <= x2 + hBorderWidth + EPSILON;\r\n  const inRangeY = point.y >= y - hBorderWidth - EPSILON && point.y <= y2 + hBorderWidth + EPSILON;\r\n  if (axis === 'x') {\r\n    return inRangeX;\r\n  } else if (axis === 'y') {\r\n    return inRangeY;\r\n  }\r\n  return inRangeX && inRangeY;\r\n}\r\n\r\n/**\r\n * @param {AnnotationElement} element\r\n * @param {boolean} useFinalPosition\r\n * @returns {Point}\r\n */\r\nfunction getElementCenterPoint(element, useFinalPosition) {\r\n  const {centerX, centerY} = element.getProps(['centerX', 'centerY'], useFinalPosition);\r\n  return {x: centerX, y: centerY};\r\n}\r\n\r\n/**\r\n * @param {string} pkg\r\n * @param {string} min\r\n * @param {string} ver\r\n * @param {boolean} [strict=true]\r\n * @returns {boolean}\r\n */\r\nfunction requireVersion(pkg, min, ver, strict = true) {\r\n  const parts = ver.split('.');\r\n  let i = 0;\r\n  for (const req of min.split('.')) {\r\n    const act = parts[i++];\r\n    if (parseInt(req, 10) < parseInt(act, 10)) {\r\n      break;\r\n    }\r\n    if (isOlderPart(act, req)) {\r\n      if (strict) {\r\n        throw new Error(`${pkg} v${ver} is not supported. v${min} or newer is required.`);\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nconst isPercentString = (s) => typeof s === 'string' && s.endsWith('%');\r\nconst toPercent = (s) => parseFloat(s) / 100;\r\nconst toPositivePercent = (s) => clamp(toPercent(s), 0, 1);\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\r\n * @typedef { import('../../types/options').AnnotationPointCoordinates } AnnotationPointCoordinates\r\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\r\n * @typedef { import('../../types/label').LabelPositionObject } LabelPositionObject\r\n */\r\n\r\n/**\r\n * @param {number} size\r\n * @param {number|string} position\r\n * @returns {number}\r\n */\r\nfunction getRelativePosition(size, position) {\r\n  if (position === 'start') {\r\n    return 0;\r\n  }\r\n  if (position === 'end') {\r\n    return size;\r\n  }\r\n  if (isPercentString(position)) {\r\n    return toPositivePercent(position) * size;\r\n  }\r\n  return size / 2;\r\n}\r\n\r\n/**\r\n * @param {number} size\r\n * @param {number|string} value\r\n * @param {boolean} [positivePercent=true]\r\n * @returns {number}\r\n */\r\nfunction getSize(size, value, positivePercent = true) {\r\n  if (typeof value === 'number') {\r\n    return value;\r\n  } else if (isPercentString(value)) {\r\n    return (positivePercent ? toPositivePercent(value) : toPercent(value)) * size;\r\n  }\r\n  return size;\r\n}\r\n\r\n/**\r\n * @param {{x: number, width: number}} size\r\n * @param {CoreLabelOptions} options\r\n * @returns {number}\r\n */\r\nfunction calculateTextAlignment(size, options) {\r\n  const {x, width} = size;\r\n  const textAlign = options.textAlign;\r\n  if (textAlign === 'center') {\r\n    return x + width / 2;\r\n  } else if (textAlign === 'end' || textAlign === 'right') {\r\n    return x + width;\r\n  }\r\n  return x;\r\n}\r\n\r\n/**\r\n * @param {{x: number|string, y: number|string}|string|number} value\r\n * @param {string|number} defaultValue\r\n * @returns {{x: number|string, y: number|string}}\r\n */\r\nfunction toPosition(value, defaultValue = 'center') {\r\n  if (isObject(value)) {\r\n    return {\r\n      x: valueOrDefault(value.x, defaultValue),\r\n      y: valueOrDefault(value.y, defaultValue),\r\n    };\r\n  }\r\n  value = valueOrDefault(value, defaultValue);\r\n  return {\r\n    x: value,\r\n    y: value\r\n  };\r\n}\r\n\r\n/**\r\n * @param {AnnotationPointCoordinates} options\r\n * @returns {boolean}\r\n */\r\nfunction isBoundToPoint(options) {\r\n  return options && (defined(options.xValue) || defined(options.yValue));\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {AnnotationBoxModel} properties\r\n * @param {CoreAnnotationOptions} options\r\n * @param {boolean} [centerBased=false]\r\n * @returns {AnnotationBoxModel}\r\n */\r\nfunction initAnimationProperties(chart, properties, options, centerBased = false) {\r\n  const initAnim = options.init;\r\n  if (!initAnim) {\r\n    return;\r\n  } else if (initAnim === true) {\r\n    return applyDefault(properties, centerBased);\r\n  }\r\n  return checkCallbackResult(properties, centerBased, callback(initAnim, [{chart, properties, options}]));\r\n}\r\n\r\n/**\r\n * @param {Object} options\r\n * @param {Array} hooks\r\n * @param {Object} hooksContainer\r\n * @returns {boolean}\r\n */\r\nfunction loadHooks(options, hooks, hooksContainer) {\r\n  let activated = false;\r\n  hooks.forEach(hook => {\r\n    if (isFunction(options[hook])) {\r\n      activated = true;\r\n      hooksContainer[hook] = options[hook];\r\n    } else if (defined(hooksContainer[hook])) {\r\n      delete hooksContainer[hook];\r\n    }\r\n  });\r\n  return activated;\r\n}\r\n\r\nfunction applyDefault({centerX, centerY}, centerBased) {\r\n  if (centerBased) {\r\n    return {centerX, centerY, radius: 0, width: 0, height: 0};\r\n  }\r\n  return {x: centerX, y: centerY, x2: centerX, y2: centerY, width: 0, height: 0};\r\n}\r\n\r\nfunction checkCallbackResult(properties, centerBased, result) {\r\n  if (result === true) {\r\n    return applyDefault(properties, centerBased);\r\n  } else if (isObject(result)) {\r\n    return result;\r\n  }\r\n}\r\n\r\nconst widthCache = new Map();\r\nconst notRadius = (radius) => isNaN(radius) || radius <= 0;\r\nconst fontsKey = (fonts) => fonts.reduce(function(prev, item) {\r\n  prev += item.string;\r\n  return prev;\r\n}, '');\r\n\r\n/**\r\n * @typedef { import('chart.js').Point } Point\r\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\r\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\r\n */\r\n\r\n/**\r\n * Determine if content is an image or a canvas.\r\n * @param {*} content\r\n * @returns boolean|undefined\r\n * @todo move this function to chart.js helpers\r\n */\r\nfunction isImageOrCanvas(content) {\r\n  if (content && typeof content === 'object') {\r\n    const type = content.toString();\r\n    return (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]');\r\n  }\r\n}\r\n\r\n/**\r\n * Set the translation on the canvas if the rotation must be applied.\r\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\r\n * @param {Point} point - the point of translation\r\n * @param {number} rotation - rotation (in degrees) to apply\r\n */\r\nfunction translate(ctx, {x, y}, rotation) {\r\n  if (rotation) {\r\n    ctx.translate(x, y);\r\n    ctx.rotate(toRadians(rotation));\r\n    ctx.translate(-x, -y);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {Object} options\r\n * @returns {boolean|undefined}\r\n */\r\nfunction setBorderStyle(ctx, options) {\r\n  if (options && options.borderWidth) {\r\n    ctx.lineCap = options.borderCapStyle;\r\n    ctx.setLineDash(options.borderDash);\r\n    ctx.lineDashOffset = options.borderDashOffset;\r\n    ctx.lineJoin = options.borderJoinStyle;\r\n    ctx.lineWidth = options.borderWidth;\r\n    ctx.strokeStyle = options.borderColor;\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {Object} options\r\n */\r\nfunction setShadowStyle(ctx, options) {\r\n  ctx.shadowColor = options.backgroundShadowColor;\r\n  ctx.shadowBlur = options.shadowBlur;\r\n  ctx.shadowOffsetX = options.shadowOffsetX;\r\n  ctx.shadowOffsetY = options.shadowOffsetY;\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {CoreLabelOptions} options\r\n * @returns {{width: number, height: number}}\r\n */\r\nfunction measureLabelSize(ctx, options) {\r\n  const content = options.content;\r\n  if (isImageOrCanvas(content)) {\r\n    return {\r\n      width: getSize(content.width, options.width),\r\n      height: getSize(content.height, options.height)\r\n    };\r\n  }\r\n  const optFont = options.font;\r\n  const fonts = isArray(optFont) ? optFont.map(f => toFont(f)) : [toFont(optFont)];\r\n  const strokeWidth = options.textStrokeWidth;\r\n  const lines = isArray(content) ? content : [content];\r\n  const mapKey = lines.join() + fontsKey(fonts) + strokeWidth + (ctx._measureText ? '-spriting' : '');\r\n  if (!widthCache.has(mapKey)) {\r\n    widthCache.set(mapKey, calculateLabelSize(ctx, lines, fonts, strokeWidth));\r\n  }\r\n  return widthCache.get(mapKey);\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{x: number, y: number, width: number, height: number}} rect\r\n * @param {Object} options\r\n */\r\nfunction drawBox(ctx, rect, options) {\r\n  const {x, y, width, height} = rect;\r\n  ctx.save();\r\n  setShadowStyle(ctx, options);\r\n  const stroke = setBorderStyle(ctx, options);\r\n  ctx.fillStyle = options.backgroundColor;\r\n  ctx.beginPath();\r\n  addRoundedRectPath(ctx, {\r\n    x, y, w: width, h: height,\r\n    radius: clampAll(toTRBLCorners(options.borderRadius), 0, Math.min(width, height) / 2)\r\n  });\r\n  ctx.closePath();\r\n  ctx.fill();\r\n  if (stroke) {\r\n    ctx.shadowColor = options.borderShadowColor;\r\n    ctx.stroke();\r\n  }\r\n  ctx.restore();\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{x: number, y: number, width: number, height: number}} rect\r\n * @param {CoreLabelOptions} options\r\n */\r\nfunction drawLabel(ctx, rect, options) {\r\n  const content = options.content;\r\n  if (isImageOrCanvas(content)) {\r\n    ctx.save();\r\n    ctx.globalAlpha = getOpacity(options.opacity, content.style.opacity);\r\n    ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\r\n    ctx.restore();\r\n    return;\r\n  }\r\n  const labels = isArray(content) ? content : [content];\r\n  const optFont = options.font;\r\n  const fonts = isArray(optFont) ? optFont.map(f => toFont(f)) : [toFont(optFont)];\r\n  const optColor = options.color;\r\n  const colors = isArray(optColor) ? optColor : [optColor];\r\n  const x = calculateTextAlignment(rect, options);\r\n  const y = rect.y + options.textStrokeWidth / 2;\r\n  ctx.save();\r\n  ctx.textBaseline = 'middle';\r\n  ctx.textAlign = options.textAlign;\r\n  if (setTextStrokeStyle(ctx, options)) {\r\n    applyLabelDecoration(ctx, {x, y}, labels, fonts);\r\n  }\r\n  applyLabelContent(ctx, {x, y}, labels, {fonts, colors});\r\n  ctx.restore();\r\n}\r\n\r\nfunction setTextStrokeStyle(ctx, options) {\r\n  if (options.textStrokeWidth > 0) {\r\n    // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\r\n    ctx.lineJoin = 'round';\r\n    ctx.miterLimit = 2;\r\n    ctx.lineWidth = options.textStrokeWidth;\r\n    ctx.strokeStyle = options.textStrokeColor;\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{radius: number, options: PointAnnotationOptions}} element\r\n * @param {number} x\r\n * @param {number} y\r\n */\r\nfunction drawPoint(ctx, element, x, y) {\r\n  const {radius, options} = element;\r\n  const style = options.pointStyle;\r\n  const rotation = options.rotation;\r\n  let rad = (rotation || 0) * RAD_PER_DEG;\r\n\r\n  if (isImageOrCanvas(style)) {\r\n    ctx.save();\r\n    ctx.translate(x, y);\r\n    ctx.rotate(rad);\r\n    ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\r\n    ctx.restore();\r\n    return;\r\n  }\r\n  if (notRadius(radius)) {\r\n    return;\r\n  }\r\n  drawPointStyle(ctx, {x, y, radius, rotation, style, rad});\r\n}\r\n\r\nfunction drawPointStyle(ctx, {x, y, radius, rotation, style, rad}) {\r\n  let xOffset, yOffset, size, cornerRadius;\r\n  ctx.beginPath();\r\n\r\n  switch (style) {\r\n  // Default includes circle\r\n  default:\r\n    ctx.arc(x, y, radius, 0, TAU);\r\n    ctx.closePath();\r\n    break;\r\n  case 'triangle':\r\n    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n    rad += TWO_THIRDS_PI;\r\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n    rad += TWO_THIRDS_PI;\r\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n    ctx.closePath();\r\n    break;\r\n  case 'rectRounded':\r\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\r\n    // `quadraticCurveTo` since it generates better results when rect is\r\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\r\n    // closer proportion to the previous impl and it is inscribed in the\r\n    // circle with `radius`. For more details, see the following PRs:\r\n    // https://github.com/chartjs/Chart.js/issues/5597\r\n    // https://github.com/chartjs/Chart.js/issues/5858\r\n    cornerRadius = radius * 0.516;\r\n    size = radius - cornerRadius;\r\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\r\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\r\n    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\r\n    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\r\n    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\r\n    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\r\n    ctx.closePath();\r\n    break;\r\n  case 'rect':\r\n    if (!rotation) {\r\n      size = Math.SQRT1_2 * radius;\r\n      ctx.rect(x - size, y - size, 2 * size, 2 * size);\r\n      break;\r\n    }\r\n    rad += QUARTER_PI;\r\n    /* falls through */\r\n  case 'rectRot':\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + yOffset, y - xOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    ctx.lineTo(x - yOffset, y + xOffset);\r\n    ctx.closePath();\r\n    break;\r\n  case 'crossRot':\r\n    rad += QUARTER_PI;\r\n    /* falls through */\r\n  case 'cross':\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    ctx.moveTo(x + yOffset, y - xOffset);\r\n    ctx.lineTo(x - yOffset, y + xOffset);\r\n    break;\r\n  case 'star':\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    ctx.moveTo(x + yOffset, y - xOffset);\r\n    ctx.lineTo(x - yOffset, y + xOffset);\r\n    rad += QUARTER_PI;\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    ctx.moveTo(x + yOffset, y - xOffset);\r\n    ctx.lineTo(x - yOffset, y + xOffset);\r\n    break;\r\n  case 'line':\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    break;\r\n  case 'dash':\r\n    ctx.moveTo(x, y);\r\n    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\r\n    break;\r\n  }\r\n\r\n  ctx.fill();\r\n}\r\n\r\nfunction calculateLabelSize(ctx, lines, fonts, strokeWidth) {\r\n  ctx.save();\r\n  const count = lines.length;\r\n  let width = 0;\r\n  let height = strokeWidth;\r\n  for (let i = 0; i < count; i++) {\r\n    const font = fonts[Math.min(i, fonts.length - 1)];\r\n    ctx.font = font.string;\r\n    const text = lines[i];\r\n    width = Math.max(width, ctx.measureText(text).width + strokeWidth);\r\n    height += font.lineHeight;\r\n  }\r\n  ctx.restore();\r\n  return {width, height};\r\n}\r\n\r\nfunction applyLabelDecoration(ctx, {x, y}, labels, fonts) {\r\n  ctx.beginPath();\r\n  let lhs = 0;\r\n  labels.forEach(function(l, i) {\r\n    const f = fonts[Math.min(i, fonts.length - 1)];\r\n    const lh = f.lineHeight;\r\n    ctx.font = f.string;\r\n    ctx.strokeText(l, x, y + lh / 2 + lhs);\r\n    lhs += lh;\r\n  });\r\n  ctx.stroke();\r\n}\r\n\r\nfunction applyLabelContent(ctx, {x, y}, labels, {fonts, colors}) {\r\n  let lhs = 0;\r\n  labels.forEach(function(l, i) {\r\n    const c = colors[Math.min(i, colors.length - 1)];\r\n    const f = fonts[Math.min(i, fonts.length - 1)];\r\n    const lh = f.lineHeight;\r\n    ctx.beginPath();\r\n    ctx.font = f.string;\r\n    ctx.fillStyle = c;\r\n    ctx.fillText(l, x, y + lh / 2 + lhs);\r\n    lhs += lh;\r\n    ctx.fill();\r\n  });\r\n}\r\n\r\nfunction getOpacity(value, elementValue) {\r\n  const opacity = isNumber(value) ? value : elementValue;\r\n  return isNumber(opacity) ? clamp(opacity, 0, 1) : 1;\r\n}\r\n\r\nconst limitedLineScale = {\r\n  xScaleID: {min: 'xMin', max: 'xMax', start: 'left', end: 'right', startProp: 'x', endProp: 'x2'},\r\n  yScaleID: {min: 'yMin', max: 'yMax', start: 'bottom', end: 'top', startProp: 'y', endProp: 'y2'}\r\n};\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import(\"chart.js\").Scale } Scale\r\n * @typedef { import(\"chart.js\").Point } Point\r\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\r\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\r\n * @typedef { import('../../types/options').LineAnnotationOptions } LineAnnotationOptions\r\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\r\n * @typedef { import('../../types/options').PolygonAnnotationOptions } PolygonAnnotationOptions\r\n */\r\n\r\n/**\r\n * @param {Scale} scale\r\n * @param {number|string} value\r\n * @param {number} fallback\r\n * @returns {number}\r\n */\r\nfunction scaleValue(scale, value, fallback) {\r\n  value = typeof value === 'number' ? value : scale.parse(value);\r\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\r\n}\r\n\r\n/**\r\n * Search the scale defined in chartjs by the axis related to the annotation options key.\r\n * @param {{ [key: string]: Scale }} scales\r\n * @param {CoreAnnotationOptions} options\r\n * @param {string} key\r\n * @returns {string}\r\n */\r\nfunction retrieveScaleID(scales, options, key) {\r\n  const scaleID = options[key];\r\n  if (scaleID || key === 'scaleID') {\r\n    return scaleID;\r\n  }\r\n  const axis = key.charAt(0);\r\n  const axes = Object.values(scales).filter((scale) => scale.axis && scale.axis === axis);\r\n  if (axes.length) {\r\n    return axes[0].id;\r\n  }\r\n  return axis;\r\n}\r\n\r\n/**\r\n * @param {Scale} scale\r\n * @param {{min: number, max: number, start: number, end: number}} options\r\n * @returns {{start: number, end: number}|undefined}\r\n */\r\nfunction getDimensionByScale(scale, options) {\r\n  if (scale) {\r\n    const reverse = scale.options.reverse;\r\n    const start = scaleValue(scale, options.min, reverse ? options.end : options.start);\r\n    const end = scaleValue(scale, options.max, reverse ? options.start : options.end);\r\n    return {\r\n      start,\r\n      end\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {CoreAnnotationOptions} options\r\n * @returns {Point}\r\n */\r\nfunction getChartPoint(chart, options) {\r\n  const {chartArea, scales} = chart;\r\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\r\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\r\n  let x = chartArea.width / 2;\r\n  let y = chartArea.height / 2;\r\n\r\n  if (xScale) {\r\n    x = scaleValue(xScale, options.xValue, xScale.left + xScale.width / 2);\r\n  }\r\n\r\n  if (yScale) {\r\n    y = scaleValue(yScale, options.yValue, yScale.top + yScale.height / 2);\r\n  }\r\n  return {x, y};\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {CoreAnnotationOptions} options\r\n * @returns {AnnotationBoxModel}\r\n */\r\nfunction resolveBoxProperties(chart, options) {\r\n  const scales = chart.scales;\r\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\r\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\r\n\r\n  if (!xScale && !yScale) {\r\n    return {};\r\n  }\r\n\r\n  let {left: x, right: x2} = xScale || chart.chartArea;\r\n  let {top: y, bottom: y2} = yScale || chart.chartArea;\r\n  const xDim = getChartDimensionByScale(xScale, {min: options.xMin, max: options.xMax, start: x, end: x2});\r\n  x = xDim.start;\r\n  x2 = xDim.end;\r\n  const yDim = getChartDimensionByScale(yScale, {min: options.yMin, max: options.yMax, start: y2, end: y});\r\n  y = yDim.start;\r\n  y2 = yDim.end;\r\n\r\n  return {\r\n    x,\r\n    y,\r\n    x2,\r\n    y2,\r\n    width: x2 - x,\r\n    height: y2 - y,\r\n    centerX: x + (x2 - x) / 2,\r\n    centerY: y + (y2 - y) / 2\r\n  };\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {PointAnnotationOptions|PolygonAnnotationOptions} options\r\n * @returns {AnnotationBoxModel}\r\n */\r\nfunction resolvePointProperties(chart, options) {\r\n  if (!isBoundToPoint(options)) {\r\n    const box = resolveBoxProperties(chart, options);\r\n    let radius = options.radius;\r\n    if (!radius || isNaN(radius)) {\r\n      radius = Math.min(box.width, box.height) / 2;\r\n      options.radius = radius;\r\n    }\r\n    const size = radius * 2;\r\n    const adjustCenterX = box.centerX + options.xAdjust;\r\n    const adjustCenterY = box.centerY + options.yAdjust;\r\n    return {\r\n      x: adjustCenterX - radius,\r\n      y: adjustCenterY - radius,\r\n      x2: adjustCenterX + radius,\r\n      y2: adjustCenterY + radius,\r\n      centerX: adjustCenterX,\r\n      centerY: adjustCenterY,\r\n      width: size,\r\n      height: size,\r\n      radius\r\n    };\r\n  }\r\n  return getChartCircle(chart, options);\r\n}\r\n/**\r\n * @param {Chart} chart\r\n * @param {LineAnnotationOptions} options\r\n * @returns {AnnotationBoxModel}\r\n */\r\nfunction resolveLineProperties(chart, options) {\r\n  const {scales, chartArea} = chart;\r\n  const scale = scales[options.scaleID];\r\n  const area = {x: chartArea.left, y: chartArea.top, x2: chartArea.right, y2: chartArea.bottom};\r\n\r\n  if (scale) {\r\n    resolveFullLineProperties(scale, area, options);\r\n  } else {\r\n    resolveLimitedLineProperties(scales, area, options);\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {CoreAnnotationOptions} options\r\n * @param {boolean} [centerBased=false]\r\n * @returns {AnnotationBoxModel}\r\n */\r\nfunction resolveBoxAndLabelProperties(chart, options, centerBased) {\r\n  const properties = resolveBoxProperties(chart, options);\r\n  properties.initProperties = initAnimationProperties(chart, properties, options, centerBased);\r\n  properties.elements = [{\r\n    type: 'label',\r\n    optionScope: 'label',\r\n    properties: resolveLabelElementProperties$1(chart, properties, options),\r\n    initProperties: properties.initProperties\r\n  }];\r\n  return properties;\r\n}\r\n\r\nfunction getChartCircle(chart, options) {\r\n  const point = getChartPoint(chart, options);\r\n  const size = options.radius * 2;\r\n  return {\r\n    x: point.x - options.radius + options.xAdjust,\r\n    y: point.y - options.radius + options.yAdjust,\r\n    x2: point.x + options.radius + options.xAdjust,\r\n    y2: point.y + options.radius + options.yAdjust,\r\n    centerX: point.x + options.xAdjust,\r\n    centerY: point.y + options.yAdjust,\r\n    radius: options.radius,\r\n    width: size,\r\n    height: size\r\n  };\r\n}\r\n\r\nfunction getChartDimensionByScale(scale, options) {\r\n  const result = getDimensionByScale(scale, options) || options;\r\n  return {\r\n    start: Math.min(result.start, result.end),\r\n    end: Math.max(result.start, result.end)\r\n  };\r\n}\r\n\r\nfunction resolveFullLineProperties(scale, area, options) {\r\n  const min = scaleValue(scale, options.value, NaN);\r\n  const max = scaleValue(scale, options.endValue, min);\r\n  if (scale.isHorizontal()) {\r\n    area.x = min;\r\n    area.x2 = max;\r\n  } else {\r\n    area.y = min;\r\n    area.y2 = max;\r\n  }\r\n}\r\n\r\nfunction resolveLimitedLineProperties(scales, area, options) {\r\n  for (const scaleId of Object.keys(limitedLineScale)) {\r\n    const scale = scales[retrieveScaleID(scales, options, scaleId)];\r\n    if (scale) {\r\n      const {min, max, start, end, startProp, endProp} = limitedLineScale[scaleId];\r\n      const dim = getDimensionByScale(scale, {min: options[min], max: options[max], start: scale[start], end: scale[end]});\r\n      area[startProp] = dim.start;\r\n      area[endProp] = dim.end;\r\n    }\r\n  }\r\n}\r\n\r\nfunction calculateX({properties, options}, labelSize, position, padding) {\r\n  const {x: start, x2: end, width: size} = properties;\r\n  return calculatePosition$1({start, end, size, borderWidth: options.borderWidth}, {\r\n    position: position.x,\r\n    padding: {start: padding.left, end: padding.right},\r\n    adjust: options.label.xAdjust,\r\n    size: labelSize.width\r\n  });\r\n}\r\n\r\nfunction calculateY({properties, options}, labelSize, position, padding) {\r\n  const {y: start, y2: end, height: size} = properties;\r\n  return calculatePosition$1({start, end, size, borderWidth: options.borderWidth}, {\r\n    position: position.y,\r\n    padding: {start: padding.top, end: padding.bottom},\r\n    adjust: options.label.yAdjust,\r\n    size: labelSize.height\r\n  });\r\n}\r\n\r\nfunction calculatePosition$1(boxOpts, labelOpts) {\r\n  const {start, end, borderWidth} = boxOpts;\r\n  const {position, padding: {start: padStart, end: padEnd}, adjust} = labelOpts;\r\n  const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\r\n  return start + borderWidth / 2 + adjust + getRelativePosition(availableSize, position);\r\n}\r\n\r\nfunction resolveLabelElementProperties$1(chart, properties, options) {\r\n  const label = options.label;\r\n  label.backgroundColor = 'transparent';\r\n  label.callout.display = false;\r\n  const position = toPosition(label.position);\r\n  const padding = toPadding(label.padding);\r\n  const labelSize = measureLabelSize(chart.ctx, label);\r\n  const x = calculateX({properties, options}, labelSize, position, padding);\r\n  const y = calculateY({properties, options}, labelSize, position, padding);\r\n  const width = labelSize.width + padding.width;\r\n  const height = labelSize.height + padding.height;\r\n  return {\r\n    x,\r\n    y,\r\n    x2: x + width,\r\n    y2: y + height,\r\n    width,\r\n    height,\r\n    centerX: x + width / 2,\r\n    centerY: y + height / 2,\r\n    rotation: label.rotation\r\n  };\r\n\r\n}\r\n\r\n/**\r\n * @typedef {import('chart.js').Point} Point\r\n */\r\n\r\n/**\r\n * Rotate a `point` relative to `center` point by `angle`\r\n * @param {Point} point - the point to rotate\r\n * @param {Point} center - center point for rotation\r\n * @param {number} angle - angle for rotation, in radians\r\n * @returns {Point} rotated point\r\n */\r\nfunction rotated(point, center, angle) {\r\n  const cos = Math.cos(angle);\r\n  const sin = Math.sin(angle);\r\n  const cx = center.x;\r\n  const cy = center.y;\r\n\r\n  return {\r\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\r\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\r\n  };\r\n}\r\n\r\nconst moveHooks = ['enter', 'leave'];\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\r\n */\r\n\r\nconst eventHooks = moveHooks.concat('click');\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {Object} state\r\n * @param {AnnotationPluginOptions} options\r\n */\r\nfunction updateListeners(chart, state, options) {\r\n  state.listened = loadHooks(options, eventHooks, state.listeners);\r\n  state.moveListened = false;\r\n  state._getElements = getElements; // for testing\r\n\r\n  moveHooks.forEach(hook => {\r\n    if (isFunction(options[hook])) {\r\n      state.moveListened = true;\r\n    }\r\n  });\r\n\r\n  if (!state.listened || !state.moveListened) {\r\n    state.annotations.forEach(scope => {\r\n      if (!state.listened && isFunction(scope.click)) {\r\n        state.listened = true;\r\n      }\r\n      if (!state.moveListened) {\r\n        moveHooks.forEach(hook => {\r\n          if (isFunction(scope[hook])) {\r\n            state.listened = true;\r\n            state.moveListened = true;\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Object} state\r\n * @param {ChartEvent} event\r\n * @param {AnnotationPluginOptions} options\r\n * @return {boolean|undefined}\r\n */\r\nfunction handleEvent(state, event, options) {\r\n  if (state.listened) {\r\n    switch (event.type) {\r\n    case 'mousemove':\r\n    case 'mouseout':\r\n      return handleMoveEvents(state, event, options);\r\n    case 'click':\r\n      return handleClickEvents(state, event, options);\r\n    }\r\n  }\r\n}\r\n\r\nfunction handleMoveEvents(state, event, options) {\r\n  if (!state.moveListened) {\r\n    return;\r\n  }\r\n\r\n  let elements;\r\n\r\n  if (event.type === 'mousemove') {\r\n    elements = getElements(state, event, options.interaction);\r\n  } else {\r\n    elements = [];\r\n  }\r\n\r\n  const previous = state.hovered;\r\n  state.hovered = elements;\r\n\r\n  const context = {state, event};\r\n  let changed = dispatchMoveEvents(context, 'leave', previous, elements);\r\n  return dispatchMoveEvents(context, 'enter', elements, previous) || changed;\r\n}\r\n\r\nfunction dispatchMoveEvents({state, event}, hook, elements, checkElements) {\r\n  let changed;\r\n  for (const element of elements) {\r\n    if (checkElements.indexOf(element) < 0) {\r\n      changed = dispatchEvent(element.options[hook] || state.listeners[hook], element, event) || changed;\r\n    }\r\n  }\r\n  return changed;\r\n}\r\n\r\nfunction handleClickEvents(state, event, options) {\r\n  const listeners = state.listeners;\r\n  const elements = getElements(state, event, options.interaction);\r\n  let changed;\r\n  for (const element of elements) {\r\n    changed = dispatchEvent(element.options.click || listeners.click, element, event) || changed;\r\n  }\r\n  return changed;\r\n}\r\n\r\nfunction dispatchEvent(handler, element, event) {\r\n  return callback(handler, [element.$context, event]) === true;\r\n}\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n */\r\n\r\nconst elementHooks = ['afterDraw', 'beforeDraw'];\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {Object} state\r\n * @param {AnnotationPluginOptions} options\r\n */\r\nfunction updateHooks(chart, state, options) {\r\n  const visibleElements = state.visibleElements;\r\n  state.hooked = loadHooks(options, elementHooks, state.hooks);\r\n\r\n  if (!state.hooked) {\r\n    visibleElements.forEach(scope => {\r\n      if (!state.hooked) {\r\n        elementHooks.forEach(hook => {\r\n          if (isFunction(scope.options[hook])) {\r\n            state.hooked = true;\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Object} state\r\n * @param {AnnotationElement} element\r\n * @param {string} hook\r\n */\r\nfunction invokeHook(state, element, hook) {\r\n  if (state.hooked) {\r\n    const callbackHook = element.options[hook] || state.hooks[hook];\r\n    return callback(callbackHook, [element.$context]);\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import(\"chart.js\").Scale } Scale\r\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\r\n */\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {Scale} scale\r\n * @param {CoreAnnotationOptions[]} annotations\r\n */\r\nfunction adjustScaleRange(chart, scale, annotations) {\r\n  const range = getScaleLimits(chart.scales, scale, annotations);\r\n  let changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');\r\n  changed = changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;\r\n  if (changed && isFunction(scale.handleTickRangeOptions)) {\r\n    scale.handleTickRangeOptions();\r\n  }\r\n}\r\n\r\n/**\r\n * @param {CoreAnnotationOptions[]} annotations\r\n * @param {{ [key: string]: Scale }} scales\r\n */\r\nfunction verifyScaleOptions(annotations, scales) {\r\n  for (const annotation of annotations) {\r\n    verifyScaleIDs(annotation, scales);\r\n  }\r\n}\r\n\r\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\r\n  if (isFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\r\n    const changed = scale[limit] !== range[limit];\r\n    scale[limit] = range[limit];\r\n    return changed;\r\n  }\r\n}\r\n\r\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\r\n  return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);\r\n}\r\n\r\nfunction verifyScaleIDs(annotation, scales) {\r\n  for (const key of ['scaleID', 'xScaleID', 'yScaleID']) {\r\n    const scaleID = retrieveScaleID(scales, annotation, key);\r\n    if (scaleID && !scales[scaleID] && verifyProperties(annotation, key)) {\r\n      console.warn(`No scale found with id '${scaleID}' for annotation '${annotation.id}'`);\r\n    }\r\n  }\r\n}\r\n\r\nfunction verifyProperties(annotation, key) {\r\n  if (key === 'scaleID') {\r\n    return true;\r\n  }\r\n  const axis = key.charAt(0);\r\n  for (const prop of ['Min', 'Max', 'Value']) {\r\n    if (defined(annotation[axis + prop])) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction getScaleLimits(scales, scale, annotations) {\r\n  const axis = scale.axis;\r\n  const scaleID = scale.id;\r\n  const scaleIDOption = axis + 'ScaleID';\r\n  const limits = {\r\n    min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),\r\n    max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)\r\n  };\r\n  for (const annotation of annotations) {\r\n    if (annotation.scaleID === scaleID) {\r\n      updateLimits(annotation, scale, ['value', 'endValue'], limits);\r\n    } else if (retrieveScaleID(scales, annotation, scaleIDOption) === scaleID) {\r\n      updateLimits(annotation, scale, [axis + 'Min', axis + 'Max', axis + 'Value'], limits);\r\n    }\r\n  }\r\n  return limits;\r\n}\r\n\r\nfunction updateLimits(annotation, scale, props, limits) {\r\n  for (const prop of props) {\r\n    const raw = annotation[prop];\r\n    if (defined(raw)) {\r\n      const value = scale.parse(raw);\r\n      limits.min = Math.min(limits.min, value);\r\n      limits.max = Math.max(limits.max, value);\r\n    }\r\n  }\r\n}\r\n\r\nclass BoxAnnotation extends Element {\r\n\r\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\r\n    const {x, y} = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\r\n    return inBoxRange({x, y}, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options.borderWidth);\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    return getElementCenterPoint(this, useFinalPosition);\r\n  }\r\n\r\n  draw(ctx) {\r\n    ctx.save();\r\n    translate(ctx, this.getCenterPoint(), this.options.rotation);\r\n    drawBox(ctx, this, this.options);\r\n    ctx.restore();\r\n  }\r\n\r\n  get label() {\r\n    return this.elements && this.elements[0];\r\n  }\r\n\r\n  resolveElementProperties(chart, options) {\r\n    return resolveBoxAndLabelProperties(chart, options);\r\n  }\r\n}\r\n\r\nBoxAnnotation.id = 'boxAnnotation';\r\n\r\nBoxAnnotation.defaults = {\r\n  adjustScaleRange: true,\r\n  backgroundShadowColor: 'transparent',\r\n  borderCapStyle: 'butt',\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderJoinStyle: 'miter',\r\n  borderRadius: 0,\r\n  borderShadowColor: 'transparent',\r\n  borderWidth: 1,\r\n  display: true,\r\n  init: undefined,\r\n  label: {\r\n    backgroundColor: 'transparent',\r\n    borderWidth: 0,\r\n    callout: {\r\n      display: false\r\n    },\r\n    color: 'black',\r\n    content: null,\r\n    display: false,\r\n    drawTime: undefined,\r\n    font: {\r\n      family: undefined,\r\n      lineHeight: undefined,\r\n      size: undefined,\r\n      style: undefined,\r\n      weight: 'bold'\r\n    },\r\n    height: undefined,\r\n    opacity: undefined,\r\n    padding: 6,\r\n    position: 'center',\r\n    rotation: undefined,\r\n    textAlign: 'start',\r\n    textStrokeColor: undefined,\r\n    textStrokeWidth: 0,\r\n    width: undefined,\r\n    xAdjust: 0,\r\n    yAdjust: 0,\r\n    z: undefined\r\n  },\r\n  rotation: 0,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0,\r\n  xMax: undefined,\r\n  xMin: undefined,\r\n  xScaleID: undefined,\r\n  yMax: undefined,\r\n  yMin: undefined,\r\n  yScaleID: undefined,\r\n  z: 0\r\n};\r\n\r\nBoxAnnotation.defaultRoutes = {\r\n  borderColor: 'color',\r\n  backgroundColor: 'color'\r\n};\r\n\r\nBoxAnnotation.descriptors = {\r\n  label: {\r\n    _fallback: true\r\n  }\r\n};\r\n\r\nconst positions = ['left', 'bottom', 'top', 'right'];\r\n\r\nclass LabelAnnotation extends Element {\r\n\r\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\r\n    const {x, y} = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.rotation));\r\n    return inBoxRange({x, y}, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options.borderWidth);\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    return getElementCenterPoint(this, useFinalPosition);\r\n  }\r\n\r\n  draw(ctx) {\r\n    const options = this.options;\r\n    const visible = !defined(this._visible) || this._visible;\r\n    if (!options.display || !options.content || !visible) {\r\n      return;\r\n    }\r\n    ctx.save();\r\n    translate(ctx, this.getCenterPoint(), this.rotation);\r\n    drawCallout(ctx, this);\r\n    drawBox(ctx, this, options);\r\n    drawLabel(ctx, getLabelSize(this), options);\r\n    ctx.restore();\r\n  }\r\n\r\n  resolveElementProperties(chart, options) {\r\n    let point;\r\n    if (!isBoundToPoint(options)) {\r\n      const {centerX, centerY} = resolveBoxProperties(chart, options);\r\n      point = {x: centerX, y: centerY};\r\n    } else {\r\n      point = getChartPoint(chart, options);\r\n    }\r\n    const padding = toPadding(options.padding);\r\n    const labelSize = measureLabelSize(chart.ctx, options);\r\n    const boxSize = measureRect(point, labelSize, options, padding);\r\n    return {\r\n      initProperties: initAnimationProperties(chart, boxSize, options),\r\n      pointX: point.x,\r\n      pointY: point.y,\r\n      ...boxSize,\r\n      rotation: options.rotation\r\n    };\r\n  }\r\n}\r\n\r\nLabelAnnotation.id = 'labelAnnotation';\r\n\r\nLabelAnnotation.defaults = {\r\n  adjustScaleRange: true,\r\n  backgroundColor: 'transparent',\r\n  backgroundShadowColor: 'transparent',\r\n  borderCapStyle: 'butt',\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderJoinStyle: 'miter',\r\n  borderRadius: 0,\r\n  borderShadowColor: 'transparent',\r\n  borderWidth: 0,\r\n  callout: {\r\n    borderCapStyle: 'butt',\r\n    borderColor: undefined,\r\n    borderDash: [],\r\n    borderDashOffset: 0,\r\n    borderJoinStyle: 'miter',\r\n    borderWidth: 1,\r\n    display: false,\r\n    margin: 5,\r\n    position: 'auto',\r\n    side: 5,\r\n    start: '50%',\r\n  },\r\n  color: 'black',\r\n  content: null,\r\n  display: true,\r\n  font: {\r\n    family: undefined,\r\n    lineHeight: undefined,\r\n    size: undefined,\r\n    style: undefined,\r\n    weight: undefined\r\n  },\r\n  height: undefined,\r\n  init: undefined,\r\n  opacity: undefined,\r\n  padding: 6,\r\n  position: 'center',\r\n  rotation: 0,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0,\r\n  textAlign: 'center',\r\n  textStrokeColor: undefined,\r\n  textStrokeWidth: 0,\r\n  width: undefined,\r\n  xAdjust: 0,\r\n  xMax: undefined,\r\n  xMin: undefined,\r\n  xScaleID: undefined,\r\n  xValue: undefined,\r\n  yAdjust: 0,\r\n  yMax: undefined,\r\n  yMin: undefined,\r\n  yScaleID: undefined,\r\n  yValue: undefined,\r\n  z: 0\r\n};\r\n\r\nLabelAnnotation.defaultRoutes = {\r\n  borderColor: 'color'\r\n};\r\n\r\nfunction measureRect(point, size, options, padding) {\r\n  const width = size.width + padding.width + options.borderWidth;\r\n  const height = size.height + padding.height + options.borderWidth;\r\n  const position = toPosition(options.position, 'center');\r\n  const x = calculatePosition(point.x, width, options.xAdjust, position.x);\r\n  const y = calculatePosition(point.y, height, options.yAdjust, position.y);\r\n\r\n  return {\r\n    x,\r\n    y,\r\n    x2: x + width,\r\n    y2: y + height,\r\n    width,\r\n    height,\r\n    centerX: x + width / 2,\r\n    centerY: y + height / 2\r\n  };\r\n}\r\n\r\nfunction calculatePosition(start, size, adjust = 0, position) {\r\n  return start - getRelativePosition(size, position) + adjust;\r\n}\r\n\r\nfunction drawCallout(ctx, element) {\r\n  const {pointX, pointY, options} = element;\r\n  const callout = options.callout;\r\n  const calloutPosition = callout && callout.display && resolveCalloutPosition(element, callout);\r\n  if (!calloutPosition || isPointInRange(element, callout, calloutPosition)) {\r\n    return;\r\n  }\r\n\r\n  ctx.save();\r\n  ctx.beginPath();\r\n  const stroke = setBorderStyle(ctx, callout);\r\n  if (!stroke) {\r\n    return ctx.restore();\r\n  }\r\n  const {separatorStart, separatorEnd} = getCalloutSeparatorCoord(element, calloutPosition);\r\n  const {sideStart, sideEnd} = getCalloutSideCoord(element, calloutPosition, separatorStart);\r\n  if (callout.margin > 0 || options.borderWidth === 0) {\r\n    ctx.moveTo(separatorStart.x, separatorStart.y);\r\n    ctx.lineTo(separatorEnd.x, separatorEnd.y);\r\n  }\r\n  ctx.moveTo(sideStart.x, sideStart.y);\r\n  ctx.lineTo(sideEnd.x, sideEnd.y);\r\n  const rotatedPoint = rotated({x: pointX, y: pointY}, element.getCenterPoint(), toRadians(-element.rotation));\r\n  ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\r\n  ctx.stroke();\r\n  ctx.restore();\r\n}\r\n\r\nfunction getCalloutSeparatorCoord(element, position) {\r\n  const {x, y, x2, y2} = element;\r\n  const adjust = getCalloutSeparatorAdjust(element, position);\r\n  let separatorStart, separatorEnd;\r\n  if (position === 'left' || position === 'right') {\r\n    separatorStart = {x: x + adjust, y};\r\n    separatorEnd = {x: separatorStart.x, y: y2};\r\n  } else {\r\n    //  position 'top' or 'bottom'\r\n    separatorStart = {x, y: y + adjust};\r\n    separatorEnd = {x: x2, y: separatorStart.y};\r\n  }\r\n  return {separatorStart, separatorEnd};\r\n}\r\n\r\nfunction getCalloutSeparatorAdjust(element, position) {\r\n  const {width, height, options} = element;\r\n  const adjust = options.callout.margin + options.borderWidth / 2;\r\n  if (position === 'right') {\r\n    return width + adjust;\r\n  } else if (position === 'bottom') {\r\n    return height + adjust;\r\n  }\r\n  return -adjust;\r\n}\r\n\r\nfunction getCalloutSideCoord(element, position, separatorStart) {\r\n  const {y, width, height, options} = element;\r\n  const start = options.callout.start;\r\n  const side = getCalloutSideAdjust(position, options.callout);\r\n  let sideStart, sideEnd;\r\n  if (position === 'left' || position === 'right') {\r\n    sideStart = {x: separatorStart.x, y: y + getSize(height, start)};\r\n    sideEnd = {x: sideStart.x + side, y: sideStart.y};\r\n  } else {\r\n    //  position 'top' or 'bottom'\r\n    sideStart = {x: separatorStart.x + getSize(width, start), y: separatorStart.y};\r\n    sideEnd = {x: sideStart.x, y: sideStart.y + side};\r\n  }\r\n  return {sideStart, sideEnd};\r\n}\r\n\r\nfunction getCalloutSideAdjust(position, options) {\r\n  const side = options.side;\r\n  if (position === 'left' || position === 'top') {\r\n    return -side;\r\n  }\r\n  return side;\r\n}\r\n\r\nfunction resolveCalloutPosition(element, options) {\r\n  const position = options.position;\r\n  if (positions.includes(position)) {\r\n    return position;\r\n  }\r\n  return resolveCalloutAutoPosition(element, options);\r\n}\r\n\r\nfunction resolveCalloutAutoPosition(element, options) {\r\n  const {x, y, x2, y2, width, height, pointX, pointY, centerX, centerY, rotation} = element;\r\n  const center = {x: centerX, y: centerY};\r\n  const start = options.start;\r\n  const xAdjust = getSize(width, start);\r\n  const yAdjust = getSize(height, start);\r\n  const xPoints = [x, x + xAdjust, x + xAdjust, x2];\r\n  const yPoints = [y + yAdjust, y2, y, y2];\r\n  const result = [];\r\n  for (let index = 0; index < 4; index++) {\r\n    const rotatedPoint = rotated({x: xPoints[index], y: yPoints[index]}, center, toRadians(rotation));\r\n    result.push({\r\n      position: positions[index],\r\n      distance: distanceBetweenPoints(rotatedPoint, {x: pointX, y: pointY})\r\n    });\r\n  }\r\n  return result.sort((a, b) => a.distance - b.distance)[0].position;\r\n}\r\n\r\nfunction getLabelSize({x, y, width, height, options}) {\r\n  const hBorderWidth = options.borderWidth / 2;\r\n  const padding = toPadding(options.padding);\r\n  return {\r\n    x: x + padding.left + hBorderWidth,\r\n    y: y + padding.top + hBorderWidth,\r\n    width: width - padding.left - padding.right - options.borderWidth,\r\n    height: height - padding.top - padding.bottom - options.borderWidth\r\n  };\r\n}\r\n\r\nfunction isPointInRange(element, callout, position) {\r\n  const {pointX, pointY} = element;\r\n  const margin = callout.margin;\r\n  let x = pointX;\r\n  let y = pointY;\r\n  if (position === 'left') {\r\n    x += margin;\r\n  } else if (position === 'right') {\r\n    x -= margin;\r\n  } else if (position === 'top') {\r\n    y += margin;\r\n  } else if (position === 'bottom') {\r\n    y -= margin;\r\n  }\r\n  return element.inRange(x, y);\r\n}\r\n\r\nconst pointInLine = (p1, p2, t) => ({x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y)});\r\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\r\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\r\nconst sqr = v => v * v;\r\nconst rangeLimit = (mouseX, mouseY, {x, y, x2, y2}, axis) => axis === 'y' ? {start: Math.min(y, y2), end: Math.max(y, y2), value: mouseY} : {start: Math.min(x, x2), end: Math.max(x, x2), value: mouseX};\r\n// http://www.independent-software.com/determining-coordinates-on-a-html-canvas-bezier-curve.html\r\nconst coordInCurve = (start, cp, end, t) => (1 - t) * (1 - t) * start + 2 * (1 - t) * t * cp + t * t * end;\r\nconst pointInCurve = (start, cp, end, t) => ({x: coordInCurve(start.x, cp.x, end.x, t), y: coordInCurve(start.y, cp.y, end.y, t)});\r\nconst coordAngleInCurve = (start, cp, end, t) => 2 * (1 - t) * (cp - start) + 2 * t * (end - cp);\r\nconst angleInCurve = (start, cp, end, t) => -Math.atan2(coordAngleInCurve(start.x, cp.x, end.x, t), coordAngleInCurve(start.y, cp.y, end.y, t)) + 0.5 * PI;\r\n\r\nclass LineAnnotation extends Element {\r\n\r\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\r\n    const hBorderWidth = this.options.borderWidth / 2;\r\n    if (axis !== 'x' && axis !== 'y') {\r\n      const point = {mouseX, mouseY};\r\n      const {path, ctx} = this;\r\n      if (path) {\r\n        setBorderStyle(ctx, this.options);\r\n        const {chart} = this.$context;\r\n        const mx = mouseX * chart.currentDevicePixelRatio;\r\n        const my = mouseY * chart.currentDevicePixelRatio;\r\n        const result = ctx.isPointInStroke(path, mx, my) || isOnLabel(this, point, useFinalPosition);\r\n        ctx.restore();\r\n        return result;\r\n      }\r\n      const epsilon = sqr(hBorderWidth);\r\n      return intersects(this, point, epsilon, useFinalPosition) || isOnLabel(this, point, useFinalPosition);\r\n    }\r\n    return inAxisRange(this, {mouseX, mouseY}, axis, {hBorderWidth, useFinalPosition});\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    return getElementCenterPoint(this, useFinalPosition);\r\n  }\r\n\r\n  draw(ctx) {\r\n    const {x, y, x2, y2, cp, options} = this;\r\n\r\n    ctx.save();\r\n    if (!setBorderStyle(ctx, options)) {\r\n      // no border width, then line is not drawn\r\n      return ctx.restore();\r\n    }\r\n    setShadowStyle(ctx, options);\r\n\r\n    const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\r\n    if (options.curve && cp) {\r\n      drawCurve(ctx, this, cp, length);\r\n      return ctx.restore();\r\n    }\r\n    const {startOpts, endOpts, startAdjust, endAdjust} = getArrowHeads(this);\r\n    const angle = Math.atan2(y2 - y, x2 - x);\r\n    ctx.translate(x, y);\r\n    ctx.rotate(angle);\r\n    ctx.beginPath();\r\n    ctx.moveTo(0 + startAdjust, 0);\r\n    ctx.lineTo(length - endAdjust, 0);\r\n    ctx.shadowColor = options.borderShadowColor;\r\n    ctx.stroke();\r\n    drawArrowHead(ctx, 0, startAdjust, startOpts);\r\n    drawArrowHead(ctx, length, -endAdjust, endOpts);\r\n    ctx.restore();\r\n  }\r\n\r\n  get label() {\r\n    return this.elements && this.elements[0];\r\n  }\r\n\r\n  resolveElementProperties(chart, options) {\r\n    const area = resolveLineProperties(chart, options);\r\n    const {x, y, x2, y2} = area;\r\n    const inside = isLineInArea(area, chart.chartArea);\r\n    const properties = inside\r\n      ? limitLineToArea({x, y}, {x: x2, y: y2}, chart.chartArea)\r\n      : {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\r\n    properties.centerX = (x2 + x) / 2;\r\n    properties.centerY = (y2 + y) / 2;\r\n    properties.initProperties = initAnimationProperties(chart, properties, options);\r\n    if (options.curve) {\r\n      const p1 = {x: properties.x, y: properties.y};\r\n      const p2 = {x: properties.x2, y: properties.y2};\r\n      properties.cp = getControlPoint(properties, options, distanceBetweenPoints(p1, p2));\r\n    }\r\n    const labelProperties = resolveLabelElementProperties(chart, properties, options.label);\r\n    // additonal prop to manage zoom/pan\r\n    labelProperties._visible = inside;\r\n\r\n    properties.elements = [{\r\n      type: 'label',\r\n      optionScope: 'label',\r\n      properties: labelProperties,\r\n      initProperties: properties.initProperties\r\n    }];\r\n    return properties;\r\n  }\r\n}\r\n\r\nLineAnnotation.id = 'lineAnnotation';\r\n\r\nconst arrowHeadsDefaults = {\r\n  backgroundColor: undefined,\r\n  backgroundShadowColor: undefined,\r\n  borderColor: undefined,\r\n  borderDash: undefined,\r\n  borderDashOffset: undefined,\r\n  borderShadowColor: undefined,\r\n  borderWidth: undefined,\r\n  display: undefined,\r\n  fill: undefined,\r\n  length: undefined,\r\n  shadowBlur: undefined,\r\n  shadowOffsetX: undefined,\r\n  shadowOffsetY: undefined,\r\n  width: undefined\r\n};\r\n\r\nLineAnnotation.defaults = {\r\n  adjustScaleRange: true,\r\n  arrowHeads: {\r\n    display: false,\r\n    end: Object.assign({}, arrowHeadsDefaults),\r\n    fill: false,\r\n    length: 12,\r\n    start: Object.assign({}, arrowHeadsDefaults),\r\n    width: 6\r\n  },\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderShadowColor: 'transparent',\r\n  borderWidth: 2,\r\n  curve: false,\r\n  controlPoint: {\r\n    y: '-50%'\r\n  },\r\n  display: true,\r\n  endValue: undefined,\r\n  init: undefined,\r\n  label: {\r\n    backgroundColor: 'rgba(0,0,0,0.8)',\r\n    backgroundShadowColor: 'transparent',\r\n    borderCapStyle: 'butt',\r\n    borderColor: 'black',\r\n    borderDash: [],\r\n    borderDashOffset: 0,\r\n    borderJoinStyle: 'miter',\r\n    borderRadius: 6,\r\n    borderShadowColor: 'transparent',\r\n    borderWidth: 0,\r\n    callout: Object.assign({}, LabelAnnotation.defaults.callout),\r\n    color: '#fff',\r\n    content: null,\r\n    display: false,\r\n    drawTime: undefined,\r\n    font: {\r\n      family: undefined,\r\n      lineHeight: undefined,\r\n      size: undefined,\r\n      style: undefined,\r\n      weight: 'bold'\r\n    },\r\n    height: undefined,\r\n    opacity: undefined,\r\n    padding: 6,\r\n    position: 'center',\r\n    rotation: 0,\r\n    shadowBlur: 0,\r\n    shadowOffsetX: 0,\r\n    shadowOffsetY: 0,\r\n    textAlign: 'center',\r\n    textStrokeColor: undefined,\r\n    textStrokeWidth: 0,\r\n    width: undefined,\r\n    xAdjust: 0,\r\n    yAdjust: 0,\r\n    z: undefined\r\n  },\r\n  scaleID: undefined,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0,\r\n  value: undefined,\r\n  xMax: undefined,\r\n  xMin: undefined,\r\n  xScaleID: undefined,\r\n  yMax: undefined,\r\n  yMin: undefined,\r\n  yScaleID: undefined,\r\n  z: 0\r\n};\r\n\r\nLineAnnotation.descriptors = {\r\n  arrowHeads: {\r\n    start: {\r\n      _fallback: true\r\n    },\r\n    end: {\r\n      _fallback: true\r\n    },\r\n    _fallback: true\r\n  }\r\n};\r\n\r\nLineAnnotation.defaultRoutes = {\r\n  borderColor: 'color'\r\n};\r\n\r\nfunction inAxisRange(element, {mouseX, mouseY}, axis, {hBorderWidth, useFinalPosition}) {\r\n  const limit = rangeLimit(mouseX, mouseY, element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis);\r\n  return (limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth) || isOnLabel(element, {mouseX, mouseY}, useFinalPosition, axis);\r\n}\r\n\r\nfunction isLineInArea({x, y, x2, y2}, {top, right, bottom, left}) {\r\n  return !(\r\n    (x < left && x2 < left) ||\r\n    (x > right && x2 > right) ||\r\n    (y < top && y2 < top) ||\r\n    (y > bottom && y2 > bottom)\r\n  );\r\n}\r\n\r\nfunction limitPointToArea({x, y}, p2, {top, right, bottom, left}) {\r\n  if (x < left) {\r\n    y = interpolateY(left, {x, y}, p2);\r\n    x = left;\r\n  }\r\n  if (x > right) {\r\n    y = interpolateY(right, {x, y}, p2);\r\n    x = right;\r\n  }\r\n  if (y < top) {\r\n    x = interpolateX(top, {x, y}, p2);\r\n    y = top;\r\n  }\r\n  if (y > bottom) {\r\n    x = interpolateX(bottom, {x, y}, p2);\r\n    y = bottom;\r\n  }\r\n  return {x, y};\r\n}\r\n\r\nfunction limitLineToArea(p1, p2, area) {\r\n  const {x, y} = limitPointToArea(p1, p2, area);\r\n  const {x: x2, y: y2} = limitPointToArea(p2, p1, area);\r\n  return {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\r\n}\r\n\r\nfunction intersects(element, {mouseX, mouseY}, epsilon = EPSILON, useFinalPosition) {\r\n  // Adapted from https://stackoverflow.com/a/6853926/25507\r\n  const {x: x1, y: y1, x2, y2} = element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  const lenSq = sqr(dx) + sqr(dy);\r\n  const t = lenSq === 0 ? -1 : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;\r\n  let xx, yy;\r\n  if (t < 0) {\r\n    xx = x1;\r\n    yy = y1;\r\n  } else if (t > 1) {\r\n    xx = x2;\r\n    yy = y2;\r\n  } else {\r\n    xx = x1 + t * dx;\r\n    yy = y1 + t * dy;\r\n  }\r\n  return (sqr(mouseX - xx) + sqr(mouseY - yy)) <= epsilon;\r\n}\r\n\r\nfunction isOnLabel(element, {mouseX, mouseY}, useFinalPosition, axis) {\r\n  const label = element.label;\r\n  return label.options.display && label.inRange(mouseX, mouseY, axis, useFinalPosition);\r\n}\r\n\r\nfunction resolveLabelElementProperties(chart, properties, options) {\r\n  const borderWidth = options.borderWidth;\r\n  const padding = toPadding(options.padding);\r\n  const textSize = measureLabelSize(chart.ctx, options);\r\n  const width = textSize.width + padding.width + borderWidth;\r\n  const height = textSize.height + padding.height + borderWidth;\r\n  return calculateLabelPosition(properties, options, {width, height, padding}, chart.chartArea);\r\n}\r\n\r\nfunction calculateAutoRotation(properties) {\r\n  const {x, y, x2, y2} = properties;\r\n  const rotation = Math.atan2(y2 - y, x2 - x);\r\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\r\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\r\n}\r\n\r\nfunction calculateLabelPosition(properties, label, sizes, chartArea) {\r\n  const {width, height, padding} = sizes;\r\n  const {xAdjust, yAdjust} = label;\r\n  const p1 = {x: properties.x, y: properties.y};\r\n  const p2 = {x: properties.x2, y: properties.y2};\r\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(properties) : toRadians(label.rotation);\r\n  const size = rotatedSize(width, height, rotation);\r\n  const t = calculateT(properties, label, {labelSize: size, padding}, chartArea);\r\n  const pt = properties.cp ? pointInCurve(p1, properties.cp, p2, t) : pointInLine(p1, p2, t);\r\n  const xCoordinateSizes = {size: size.w, min: chartArea.left, max: chartArea.right, padding: padding.left};\r\n  const yCoordinateSizes = {size: size.h, min: chartArea.top, max: chartArea.bottom, padding: padding.top};\r\n  const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;\r\n  const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;\r\n  return {\r\n    x: centerX - (width / 2),\r\n    y: centerY - (height / 2),\r\n    x2: centerX + (width / 2),\r\n    y2: centerY + (height / 2),\r\n    centerX,\r\n    centerY,\r\n    pointX: pt.x,\r\n    pointY: pt.y,\r\n    width,\r\n    height,\r\n    rotation: toDegrees(rotation)\r\n  };\r\n}\r\n\r\nfunction rotatedSize(width, height, rotation) {\r\n  const cos = Math.cos(rotation);\r\n  const sin = Math.sin(rotation);\r\n  return {\r\n    w: Math.abs(width * cos) + Math.abs(height * sin),\r\n    h: Math.abs(width * sin) + Math.abs(height * cos)\r\n  };\r\n}\r\n\r\nfunction calculateT(properties, label, sizes, chartArea) {\r\n  let t;\r\n  const space = spaceAround(properties, chartArea);\r\n  if (label.position === 'start') {\r\n    t = calculateTAdjust({w: properties.x2 - properties.x, h: properties.y2 - properties.y}, sizes, label, space);\r\n  } else if (label.position === 'end') {\r\n    t = 1 - calculateTAdjust({w: properties.x - properties.x2, h: properties.y - properties.y2}, sizes, label, space);\r\n  } else {\r\n    t = getRelativePosition(1, label.position);\r\n  }\r\n  return t;\r\n}\r\n\r\nfunction calculateTAdjust(lineSize, sizes, label, space) {\r\n  const {labelSize, padding} = sizes;\r\n  const lineW = lineSize.w * space.dx;\r\n  const lineH = lineSize.h * space.dy;\r\n  const x = (lineW > 0) && ((labelSize.w / 2 + padding.left - space.x) / lineW);\r\n  const y = (lineH > 0) && ((labelSize.h / 2 + padding.top - space.y) / lineH);\r\n  return clamp(Math.max(x, y), 0, 0.25);\r\n}\r\n\r\nfunction spaceAround(properties, chartArea) {\r\n  const {x, x2, y, y2} = properties;\r\n  const t = Math.min(y, y2) - chartArea.top;\r\n  const l = Math.min(x, x2) - chartArea.left;\r\n  const b = chartArea.bottom - Math.max(y, y2);\r\n  const r = chartArea.right - Math.max(x, x2);\r\n  return {\r\n    x: Math.min(l, r),\r\n    y: Math.min(t, b),\r\n    dx: l <= r ? 1 : -1,\r\n    dy: t <= b ? 1 : -1\r\n  };\r\n}\r\n\r\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\r\n  const {size, min, max, padding} = labelSizes;\r\n  const halfSize = size / 2;\r\n  if (size > max - min) {\r\n    // if it does not fit, display as much as possible\r\n    return (max + min) / 2;\r\n  }\r\n  if (min >= (coordinate - padding - halfSize)) {\r\n    coordinate = min + padding + halfSize;\r\n  }\r\n  if (max <= (coordinate + padding + halfSize)) {\r\n    coordinate = max - padding - halfSize;\r\n  }\r\n  return coordinate;\r\n}\r\n\r\nfunction getArrowHeads(line) {\r\n  const options = line.options;\r\n  const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\r\n  const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\r\n  return {\r\n    startOpts: arrowStartOpts,\r\n    endOpts: arrowEndOpts,\r\n    startAdjust: getLineAdjust(line, arrowStartOpts),\r\n    endAdjust: getLineAdjust(line, arrowEndOpts)\r\n  };\r\n}\r\n\r\nfunction getLineAdjust(line, arrowOpts) {\r\n  if (!arrowOpts || !arrowOpts.display) {\r\n    return 0;\r\n  }\r\n  const {length, width} = arrowOpts;\r\n  const adjust = line.options.borderWidth / 2;\r\n  const p1 = {x: length, y: width + adjust};\r\n  const p2 = {x: 0, y: adjust};\r\n  return Math.abs(interpolateX(0, p1, p2));\r\n}\r\n\r\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\r\n  if (!arrowOpts || !arrowOpts.display) {\r\n    return;\r\n  }\r\n  const {length, width, fill, backgroundColor, borderColor} = arrowOpts;\r\n  const arrowOffsetX = Math.abs(offset - length) + adjust;\r\n  ctx.beginPath();\r\n  setShadowStyle(ctx, arrowOpts);\r\n  setBorderStyle(ctx, arrowOpts);\r\n  ctx.moveTo(arrowOffsetX, -width);\r\n  ctx.lineTo(offset + adjust, 0);\r\n  ctx.lineTo(arrowOffsetX, width);\r\n  if (fill === true) {\r\n    ctx.fillStyle = backgroundColor || borderColor;\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    ctx.shadowColor = 'transparent';\r\n  } else {\r\n    ctx.shadowColor = arrowOpts.borderShadowColor;\r\n  }\r\n  ctx.stroke();\r\n}\r\n\r\nfunction getControlPoint(properties, options, distance) {\r\n  const {x, y, x2, y2, centerX, centerY} = properties;\r\n  const angle = Math.atan2(y2 - y, x2 - x);\r\n  const cp = toPosition(options.controlPoint, 0);\r\n  const point = {\r\n    x: centerX + getSize(distance, cp.x, false),\r\n    y: centerY + getSize(distance, cp.y, false)\r\n  };\r\n  return rotated(point, {x: centerX, y: centerY}, angle);\r\n}\r\n\r\nfunction drawArrowHeadOnCurve(ctx, {x, y}, {angle, adjust}, arrowOpts) {\r\n  if (!arrowOpts || !arrowOpts.display) {\r\n    return;\r\n  }\r\n  ctx.save();\r\n  ctx.translate(x, y);\r\n  ctx.rotate(angle);\r\n  drawArrowHead(ctx, 0, -adjust, arrowOpts);\r\n  ctx.restore();\r\n}\r\n\r\nfunction drawCurve(ctx, element, cp, length) {\r\n  const {x, y, x2, y2, options} = element;\r\n  const {startOpts, endOpts, startAdjust, endAdjust} = getArrowHeads(element);\r\n  const p1 = {x, y};\r\n  const p2 = {x: x2, y: y2};\r\n  const startAngle = angleInCurve(p1, cp, p2, 0);\r\n  const endAngle = angleInCurve(p1, cp, p2, 1) - PI;\r\n  const ps = pointInCurve(p1, cp, p2, startAdjust / length);\r\n  const pe = pointInCurve(p1, cp, p2, 1 - endAdjust / length);\r\n\r\n  const path = new Path2D();\r\n  ctx.beginPath();\r\n  path.moveTo(ps.x, ps.y);\r\n  path.quadraticCurveTo(cp.x, cp.y, pe.x, pe.y);\r\n  ctx.shadowColor = options.borderShadowColor;\r\n  ctx.stroke(path);\r\n  element.path = path;\r\n  element.ctx = ctx;\r\n  drawArrowHeadOnCurve(ctx, ps, {angle: startAngle, adjust: startAdjust}, startOpts);\r\n  drawArrowHeadOnCurve(ctx, pe, {angle: endAngle, adjust: endAdjust}, endOpts);\r\n}\r\n\r\nclass EllipseAnnotation extends Element {\r\n\r\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\r\n    const rotation = this.options.rotation;\r\n    const borderWidth = this.options.borderWidth;\r\n    if (axis !== 'x' && axis !== 'y') {\r\n      return pointInEllipse({x: mouseX, y: mouseY}, this.getProps(['width', 'height', 'centerX', 'centerY'], useFinalPosition), rotation, borderWidth);\r\n    }\r\n    const {x, y, x2, y2} = this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\r\n    const hBorderWidth = borderWidth / 2;\r\n    const limit = axis === 'y' ? {start: y, end: y2} : {start: x, end: x2};\r\n    const rotatedPoint = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-rotation));\r\n    return rotatedPoint[axis] >= limit.start - hBorderWidth - EPSILON && rotatedPoint[axis] <= limit.end + hBorderWidth + EPSILON;\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    return getElementCenterPoint(this, useFinalPosition);\r\n  }\r\n\r\n  draw(ctx) {\r\n    const {width, height, centerX, centerY, options} = this;\r\n    ctx.save();\r\n    translate(ctx, this.getCenterPoint(), options.rotation);\r\n    setShadowStyle(ctx, this.options);\r\n    ctx.beginPath();\r\n    ctx.fillStyle = options.backgroundColor;\r\n    const stroke = setBorderStyle(ctx, options);\r\n    ctx.ellipse(centerX, centerY, height / 2, width / 2, PI / 2, 0, 2 * PI);\r\n    ctx.fill();\r\n    if (stroke) {\r\n      ctx.shadowColor = options.borderShadowColor;\r\n      ctx.stroke();\r\n    }\r\n    ctx.restore();\r\n  }\r\n\r\n  get label() {\r\n    return this.elements && this.elements[0];\r\n  }\r\n\r\n  resolveElementProperties(chart, options) {\r\n    return resolveBoxAndLabelProperties(chart, options, true);\r\n  }\r\n\r\n}\r\n\r\nEllipseAnnotation.id = 'ellipseAnnotation';\r\n\r\nEllipseAnnotation.defaults = {\r\n  adjustScaleRange: true,\r\n  backgroundShadowColor: 'transparent',\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderShadowColor: 'transparent',\r\n  borderWidth: 1,\r\n  display: true,\r\n  init: undefined,\r\n  label: Object.assign({}, BoxAnnotation.defaults.label),\r\n  rotation: 0,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0,\r\n  xMax: undefined,\r\n  xMin: undefined,\r\n  xScaleID: undefined,\r\n  yMax: undefined,\r\n  yMin: undefined,\r\n  yScaleID: undefined,\r\n  z: 0\r\n};\r\n\r\nEllipseAnnotation.defaultRoutes = {\r\n  borderColor: 'color',\r\n  backgroundColor: 'color'\r\n};\r\n\r\nEllipseAnnotation.descriptors = {\r\n  label: {\r\n    _fallback: true\r\n  }\r\n};\r\n\r\nfunction pointInEllipse(p, ellipse, rotation, borderWidth) {\r\n  const {width, height, centerX, centerY} = ellipse;\r\n  const xRadius = width / 2;\r\n  const yRadius = height / 2;\r\n\r\n  if (xRadius <= 0 || yRadius <= 0) {\r\n    return false;\r\n  }\r\n  // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\r\n  const angle = toRadians(rotation || 0);\r\n  const hBorderWidth = borderWidth / 2 || 0;\r\n  const cosAngle = Math.cos(angle);\r\n  const sinAngle = Math.sin(angle);\r\n  const a = Math.pow(cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY), 2);\r\n  const b = Math.pow(sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY), 2);\r\n  return (a / Math.pow(xRadius + hBorderWidth, 2)) + (b / Math.pow(yRadius + hBorderWidth, 2)) <= 1.0001;\r\n}\r\n\r\nclass PointAnnotation extends Element {\r\n\r\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\r\n    const {x, y, x2, y2, width} = this.getProps(['x', 'y', 'x2', 'y2', 'width'], useFinalPosition);\r\n    const borderWidth = this.options.borderWidth;\r\n    if (axis !== 'x' && axis !== 'y') {\r\n      return inPointRange({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), width / 2, borderWidth);\r\n    }\r\n    const hBorderWidth = borderWidth / 2;\r\n    const limit = axis === 'y' ? {start: y, end: y2, value: mouseY} : {start: x, end: x2, value: mouseX};\r\n    return limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth;\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    return getElementCenterPoint(this, useFinalPosition);\r\n  }\r\n\r\n  draw(ctx) {\r\n    const options = this.options;\r\n    const borderWidth = options.borderWidth;\r\n    if (options.radius < 0.1) {\r\n      return;\r\n    }\r\n    ctx.save();\r\n    ctx.fillStyle = options.backgroundColor;\r\n    setShadowStyle(ctx, options);\r\n    const stroke = setBorderStyle(ctx, options);\r\n    drawPoint(ctx, this, this.centerX, this.centerY);\r\n    if (stroke && !isImageOrCanvas(options.pointStyle)) {\r\n      ctx.shadowColor = options.borderShadowColor;\r\n      ctx.stroke();\r\n    }\r\n    ctx.restore();\r\n    options.borderWidth = borderWidth;\r\n  }\r\n\r\n  resolveElementProperties(chart, options) {\r\n    const properties = resolvePointProperties(chart, options);\r\n    properties.initProperties = initAnimationProperties(chart, properties, options, true);\r\n    return properties;\r\n  }\r\n}\r\n\r\nPointAnnotation.id = 'pointAnnotation';\r\n\r\nPointAnnotation.defaults = {\r\n  adjustScaleRange: true,\r\n  backgroundShadowColor: 'transparent',\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderShadowColor: 'transparent',\r\n  borderWidth: 1,\r\n  display: true,\r\n  init: undefined,\r\n  pointStyle: 'circle',\r\n  radius: 10,\r\n  rotation: 0,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0,\r\n  xAdjust: 0,\r\n  xMax: undefined,\r\n  xMin: undefined,\r\n  xScaleID: undefined,\r\n  xValue: undefined,\r\n  yAdjust: 0,\r\n  yMax: undefined,\r\n  yMin: undefined,\r\n  yScaleID: undefined,\r\n  yValue: undefined,\r\n  z: 0\r\n};\r\n\r\nPointAnnotation.defaultRoutes = {\r\n  borderColor: 'color',\r\n  backgroundColor: 'color'\r\n};\r\n\r\nclass PolygonAnnotation extends Element {\r\n\r\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\r\n    if (axis !== 'x' && axis !== 'y') {\r\n      return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\r\n    }\r\n    const rotatedPoint = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\r\n    const axisPoints = this.elements.map((point) => axis === 'y' ? point.bY : point.bX);\r\n    const start = Math.min(...axisPoints);\r\n    const end = Math.max(...axisPoints);\r\n    return rotatedPoint[axis] >= start && rotatedPoint[axis] <= end;\r\n  }\r\n\r\n  getCenterPoint(useFinalPosition) {\r\n    return getElementCenterPoint(this, useFinalPosition);\r\n  }\r\n\r\n  draw(ctx) {\r\n    const {elements, options} = this;\r\n    ctx.save();\r\n    ctx.beginPath();\r\n    ctx.fillStyle = options.backgroundColor;\r\n    setShadowStyle(ctx, options);\r\n    const stroke = setBorderStyle(ctx, options);\r\n    let first = true;\r\n    for (const el of elements) {\r\n      if (first) {\r\n        ctx.moveTo(el.x, el.y);\r\n        first = false;\r\n      } else {\r\n        ctx.lineTo(el.x, el.y);\r\n      }\r\n    }\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    // If no border, don't draw it\r\n    if (stroke) {\r\n      ctx.shadowColor = options.borderShadowColor;\r\n      ctx.stroke();\r\n    }\r\n    ctx.restore();\r\n  }\r\n\r\n  resolveElementProperties(chart, options) {\r\n    const properties = resolvePointProperties(chart, options);\r\n    const {sides, rotation} = options;\r\n    const elements = [];\r\n    const angle = (2 * PI) / sides;\r\n    let rad = rotation * RAD_PER_DEG;\r\n    for (let i = 0; i < sides; i++, rad += angle) {\r\n      const elProps = buildPointElement(properties, options, rad);\r\n      elProps.initProperties = initAnimationProperties(chart, properties, options);\r\n      elements.push(elProps);\r\n    }\r\n    properties.elements = elements;\r\n    return properties;\r\n  }\r\n}\r\n\r\nPolygonAnnotation.id = 'polygonAnnotation';\r\n\r\nPolygonAnnotation.defaults = {\r\n  adjustScaleRange: true,\r\n  backgroundShadowColor: 'transparent',\r\n  borderCapStyle: 'butt',\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderJoinStyle: 'miter',\r\n  borderShadowColor: 'transparent',\r\n  borderWidth: 1,\r\n  display: true,\r\n  init: undefined,\r\n  point: {\r\n    radius: 0\r\n  },\r\n  radius: 10,\r\n  rotation: 0,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0,\r\n  sides: 3,\r\n  xAdjust: 0,\r\n  xMax: undefined,\r\n  xMin: undefined,\r\n  xScaleID: undefined,\r\n  xValue: undefined,\r\n  yAdjust: 0,\r\n  yMax: undefined,\r\n  yMin: undefined,\r\n  yScaleID: undefined,\r\n  yValue: undefined,\r\n  z: 0\r\n};\r\n\r\nPolygonAnnotation.defaultRoutes = {\r\n  borderColor: 'color',\r\n  backgroundColor: 'color'\r\n};\r\n\r\nfunction buildPointElement({centerX, centerY}, {radius, borderWidth}, rad) {\r\n  const halfBorder = borderWidth / 2;\r\n  const sin = Math.sin(rad);\r\n  const cos = Math.cos(rad);\r\n  const point = {x: centerX + sin * radius, y: centerY - cos * radius};\r\n  return {\r\n    type: 'point',\r\n    optionScope: 'point',\r\n    properties: {\r\n      x: point.x,\r\n      y: point.y,\r\n      centerX: point.x,\r\n      centerY: point.y,\r\n      bX: centerX + sin * (radius + halfBorder),\r\n      bY: centerY - cos * (radius + halfBorder)\r\n    }\r\n  };\r\n}\r\n\r\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\r\n  let isInside = false;\r\n  let A = points[points.length - 1].getProps(['bX', 'bY'], useFinalPosition);\r\n  for (const point of points) {\r\n    const B = point.getProps(['bX', 'bY'], useFinalPosition);\r\n    if ((B.bY > y) !== (A.bY > y) && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\r\n      isInside = !isInside;\r\n    }\r\n    A = B;\r\n  }\r\n  return isInside;\r\n}\r\n\r\nconst annotationTypes = {\r\n  box: BoxAnnotation,\r\n  ellipse: EllipseAnnotation,\r\n  label: LabelAnnotation,\r\n  line: LineAnnotation,\r\n  point: PointAnnotation,\r\n  polygon: PolygonAnnotation\r\n};\r\n\r\n/**\r\n * Register fallback for annotation elements\r\n * For example lineAnnotation options would be looked through:\r\n * - the annotation object (options.plugins.annotation.annotations[id])\r\n * - element options (options.elements.lineAnnotation)\r\n * - element defaults (defaults.elements.lineAnnotation)\r\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\r\n */\r\nObject.keys(annotationTypes).forEach(key => {\r\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\r\n    _fallback: 'plugins.annotation.common'\r\n  });\r\n});\r\n\r\nconst directUpdater = {\r\n  update: Object.assign\r\n};\r\n\r\nconst hooks$1 = eventHooks.concat(elementHooks);\r\nconst resolve = (value, optDefs) => isObject(optDefs) ? resolveObj(value, optDefs) : value;\r\n\r\n\r\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import(\"chart.js\").UpdateMode } UpdateMode\r\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\r\n */\r\n\r\n/**\r\n * @param {string} prop\r\n * @returns {boolean}\r\n */\r\nconst isIndexable = (prop) => prop === 'color' || prop === 'font';\r\n\r\n/**\r\n * Resolve the annotation type, checking if is supported.\r\n * @param {string} [type=line] - annotation type\r\n * @returns {string} resolved annotation type\r\n */\r\nfunction resolveType(type = 'line') {\r\n  if (annotationTypes[type]) {\r\n    return type;\r\n  }\r\n  console.warn(`Unknown annotation type: '${type}', defaulting to 'line'`);\r\n  return 'line';\r\n}\r\n\r\n/**\r\n * @param {Chart} chart\r\n * @param {Object} state\r\n * @param {AnnotationPluginOptions} options\r\n * @param {UpdateMode} mode\r\n */\r\nfunction updateElements(chart, state, options, mode) {\r\n  const animations = resolveAnimations(chart, options.animations, mode);\r\n\r\n  const annotations = state.annotations;\r\n  const elements = resyncElements(state.elements, annotations);\r\n\r\n  for (let i = 0; i < annotations.length; i++) {\r\n    const annotationOptions = annotations[i];\r\n    const element = getOrCreateElement(elements, i, annotationOptions.type);\r\n    const resolver = annotationOptions.setContext(getContext(chart, element, annotationOptions));\r\n    const properties = element.resolveElementProperties(chart, resolver);\r\n\r\n    properties.skip = toSkip(properties);\r\n\r\n    if ('elements' in properties) {\r\n      updateSubElements(element, properties.elements, resolver, animations);\r\n      // Remove the sub-element definitions from properties, so the actual elements\r\n      // are not overwritten by their definitions\r\n      delete properties.elements;\r\n    }\r\n\r\n    if (!defined(element.x)) {\r\n      // If the element is newly created, assing the properties directly - to\r\n      // make them readily awailable to any scriptable options. If we do not do this,\r\n      // the properties retruned by `resolveElementProperties` are available only\r\n      // after options resolution.\r\n      Object.assign(element, properties);\r\n    }\r\n\r\n    Object.assign(element, properties.initProperties);\r\n    properties.options = resolveAnnotationOptions(resolver);\r\n\r\n    animations.update(element, properties);\r\n  }\r\n}\r\n\r\nfunction toSkip(properties) {\r\n  return isNaN(properties.x) || isNaN(properties.y);\r\n}\r\n\r\nfunction resolveAnimations(chart, animOpts, mode) {\r\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\r\n    return directUpdater;\r\n  }\r\n  return new Animations(chart, animOpts);\r\n}\r\n\r\nfunction updateSubElements(mainElement, elements, resolver, animations) {\r\n  const subElements = mainElement.elements || (mainElement.elements = []);\r\n  subElements.length = elements.length;\r\n  for (let i = 0; i < elements.length; i++) {\r\n    const definition = elements[i];\r\n    const properties = definition.properties;\r\n    const subElement = getOrCreateElement(subElements, i, definition.type, definition.initProperties);\r\n    const subResolver = resolver[definition.optionScope].override(definition);\r\n    properties.options = resolveAnnotationOptions(subResolver);\r\n    animations.update(subElement, properties);\r\n  }\r\n}\r\n\r\nfunction getOrCreateElement(elements, index, type, initProperties) {\r\n  const elementClass = annotationTypes[resolveType(type)];\r\n  let element = elements[index];\r\n  if (!element || !(element instanceof elementClass)) {\r\n    element = elements[index] = new elementClass();\r\n    Object.assign(element, initProperties);\r\n  }\r\n  return element;\r\n}\r\n\r\nfunction resolveAnnotationOptions(resolver) {\r\n  const elementClass = annotationTypes[resolveType(resolver.type)];\r\n  const result = {};\r\n  result.id = resolver.id;\r\n  result.type = resolver.type;\r\n  result.drawTime = resolver.drawTime;\r\n  Object.assign(result,\r\n    resolveObj(resolver, elementClass.defaults),\r\n    resolveObj(resolver, elementClass.defaultRoutes));\r\n  for (const hook of hooks$1) {\r\n    result[hook] = resolver[hook];\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction resolveObj(resolver, defs) {\r\n  const result = {};\r\n  for (const prop of Object.keys(defs)) {\r\n    const optDefs = defs[prop];\r\n    const value = resolver[prop];\r\n    if (isIndexable(prop) && isArray(value)) {\r\n      result[prop] = value.map((item) => resolve(item, optDefs));\r\n    } else {\r\n      result[prop] = resolve(value, optDefs);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction getContext(chart, element, annotation) {\r\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\r\n    element,\r\n    id: annotation.id,\r\n    type: 'annotation'\r\n  }));\r\n}\r\n\r\nfunction resyncElements(elements, annotations) {\r\n  const count = annotations.length;\r\n  const start = elements.length;\r\n\r\n  if (start < count) {\r\n    const add = count - start;\r\n    elements.splice(start, 0, ...new Array(add));\r\n  } else if (start > count) {\r\n    elements.splice(count, start - count);\r\n  }\r\n  return elements;\r\n}\r\n\r\nvar version = \"2.2.1\";\r\n\r\nconst chartStates = new Map();\r\nconst hooks = eventHooks.concat(elementHooks);\r\n\r\nvar annotation = {\r\n  id: 'annotation',\r\n\r\n  version,\r\n\r\n  beforeRegister() {\r\n    requireVersion('chart.js', '3.7', Chart.version);\r\n  },\r\n\r\n  afterRegister() {\r\n    Chart.register(annotationTypes);\r\n  },\r\n\r\n  afterUnregister() {\r\n    Chart.unregister(annotationTypes);\r\n  },\r\n\r\n  beforeInit(chart) {\r\n    chartStates.set(chart, {\r\n      annotations: [],\r\n      elements: [],\r\n      visibleElements: [],\r\n      listeners: {},\r\n      listened: false,\r\n      moveListened: false,\r\n      hooks: {},\r\n      hooked: false,\r\n      hovered: []\r\n    });\r\n  },\r\n\r\n  beforeUpdate(chart, args, options) {\r\n    const state = chartStates.get(chart);\r\n    const annotations = state.annotations = [];\r\n\r\n    let annotationOptions = options.annotations;\r\n    if (isObject(annotationOptions)) {\r\n      Object.keys(annotationOptions).forEach(key => {\r\n        const value = annotationOptions[key];\r\n        if (isObject(value)) {\r\n          value.id = key;\r\n          annotations.push(value);\r\n        }\r\n      });\r\n    } else if (isArray(annotationOptions)) {\r\n      annotations.push(...annotationOptions);\r\n    }\r\n    verifyScaleOptions(annotations, chart.scales);\r\n  },\r\n\r\n  afterDataLimits(chart, args) {\r\n    const state = chartStates.get(chart);\r\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\r\n  },\r\n\r\n  afterUpdate(chart, args, options) {\r\n    const state = chartStates.get(chart);\r\n    updateListeners(chart, state, options);\r\n    updateElements(chart, state, options, args.mode);\r\n    state.visibleElements = state.elements.filter(el => !el.skip && el.options.display);\r\n    updateHooks(chart, state, options);\r\n  },\r\n\r\n  beforeDatasetsDraw(chart, _args, options) {\r\n    draw(chart, 'beforeDatasetsDraw', options.clip);\r\n  },\r\n\r\n  afterDatasetsDraw(chart, _args, options) {\r\n    draw(chart, 'afterDatasetsDraw', options.clip);\r\n  },\r\n\r\n  beforeDraw(chart, _args, options) {\r\n    draw(chart, 'beforeDraw', options.clip);\r\n  },\r\n\r\n  afterDraw(chart, _args, options) {\r\n    draw(chart, 'afterDraw', options.clip);\r\n  },\r\n\r\n  beforeEvent(chart, args, options) {\r\n    const state = chartStates.get(chart);\r\n    if (handleEvent(state, args.event, options)) {\r\n      args.changed = true;\r\n    }\r\n  },\r\n\r\n  afterDestroy(chart) {\r\n    chartStates.delete(chart);\r\n  },\r\n\r\n  _getState(chart) {\r\n    return chartStates.get(chart);\r\n  },\r\n\r\n  defaults: {\r\n    animations: {\r\n      numbers: {\r\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height', 'centerX', 'centerY', 'pointX', 'pointY', 'radius'],\r\n        type: 'number'\r\n      },\r\n    },\r\n    clip: true,\r\n    interaction: {\r\n      mode: undefined,\r\n      axis: undefined,\r\n      intersect: undefined\r\n    },\r\n    common: {\r\n      drawTime: 'afterDatasetsDraw',\r\n      init: false,\r\n      label: {\r\n      }\r\n    }\r\n  },\r\n\r\n  descriptors: {\r\n    _indexable: false,\r\n    _scriptable: (prop) => !hooks.includes(prop) && prop !== 'init',\r\n    annotations: {\r\n      _allKeys: false,\r\n      _fallback: (prop, opts) => `elements.${annotationTypes[resolveType(opts.type)].id}`\r\n    },\r\n    interaction: {\r\n      _fallback: true\r\n    },\r\n    common: {\r\n      label: {\r\n        _indexable: isIndexable,\r\n        _fallback: true\r\n      },\r\n      _indexable: isIndexable\r\n    }\r\n  },\r\n\r\n  additionalOptionScopes: ['']\r\n};\r\n\r\nfunction draw(chart, caller, clip) {\r\n  const {ctx, chartArea} = chart;\r\n  const state = chartStates.get(chart);\r\n\r\n  if (clip) {\r\n    clipArea(ctx, chartArea);\r\n  }\r\n\r\n  const drawableElements = getDrawableElements(state.visibleElements, caller).sort((a, b) => a.element.options.z - b.element.options.z);\r\n  for (const item of drawableElements) {\r\n    drawElement(ctx, chartArea, state, item);\r\n  }\r\n\r\n  if (clip) {\r\n    unclipArea(ctx);\r\n  }\r\n}\r\n\r\nfunction getDrawableElements(elements, caller) {\r\n  const drawableElements = [];\r\n  for (const el of elements) {\r\n    if (el.options.drawTime === caller) {\r\n      drawableElements.push({element: el, main: true});\r\n    }\r\n    if (el.elements && el.elements.length) {\r\n      for (const sub of el.elements) {\r\n        if (sub.options.display && sub.options.drawTime === caller) {\r\n          drawableElements.push({element: sub});\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return drawableElements;\r\n}\r\n\r\nfunction drawElement(ctx, chartArea, state, item) {\r\n  const el = item.element;\r\n  if (item.main) {\r\n    invokeHook(state, el, 'beforeDraw');\r\n    el.draw(ctx, chartArea);\r\n    invokeHook(state, el, 'afterDraw');\r\n  } else {\r\n    el.draw(ctx, chartArea);\r\n  }\r\n}\r\n\r\nexport { annotation as default };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}